{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Golden Gate \u00b6 Work In Progress This documentation is not yet complete. As we migrate the project from an internal project to one that can be shared with others, we are busy migrating some of the documentation from internal Wiki pages, Google docs and slide decks. Golden Gate is a portable cross-platform framework that offers reliable and secure network communication between different combinations of embedded devices, mobile applications and desktop applications. It can run in many environments, from embedded systems with very limited resources like wearables and IoT devices, to mobile and desktop applications. The framework includes a core set of components that can be combined to build IP-based network stacks. A stack running on a device or within a mobile app connects to another, compatible stack running on a remote device or mobile app over some transport or link, typically Bluetooth. On top of the stack are clients or servers that access or expose some functionality. In the current version of the framework, the clients and servers are CoAP endpoints. In future versions, other application protocols will be supported, like Web Sockets and HTTP. The project consists of: A core library written in C Language bindings for higher level languages, including Kotlin and Swift A modular build system based on CMake Code examples Tools and applications Support for test automation Documentation Documentation Sections \u00b6 Introduction - A high level introduction to the project Getting Started - How to get started building and using the framework Architecture - Architecture of the framework Developer Guides - Collection of developer guides API Reference - Detailed API documentation for C, Kotlin and Swift Platforms - Platform-specific documentation Transports - Transport-specific documentation Release Notes - What's new and changed in each release Glossary - Definition of terms FAQ - Frequently asked questions, and answers","title":"Home"},{"location":"index.html#welcome-to-golden-gate","text":"Work In Progress This documentation is not yet complete. As we migrate the project from an internal project to one that can be shared with others, we are busy migrating some of the documentation from internal Wiki pages, Google docs and slide decks. Golden Gate is a portable cross-platform framework that offers reliable and secure network communication between different combinations of embedded devices, mobile applications and desktop applications. It can run in many environments, from embedded systems with very limited resources like wearables and IoT devices, to mobile and desktop applications. The framework includes a core set of components that can be combined to build IP-based network stacks. A stack running on a device or within a mobile app connects to another, compatible stack running on a remote device or mobile app over some transport or link, typically Bluetooth. On top of the stack are clients or servers that access or expose some functionality. In the current version of the framework, the clients and servers are CoAP endpoints. In future versions, other application protocols will be supported, like Web Sockets and HTTP. The project consists of: A core library written in C Language bindings for higher level languages, including Kotlin and Swift A modular build system based on CMake Code examples Tools and applications Support for test automation Documentation","title":"Welcome to Golden Gate"},{"location":"index.html#documentation-sections","text":"Introduction - A high level introduction to the project Getting Started - How to get started building and using the framework Architecture - Architecture of the framework Developer Guides - Collection of developer guides API Reference - Detailed API documentation for C, Kotlin and Swift Platforms - Platform-specific documentation Transports - Transport-specific documentation Release Notes - What's new and changed in each release Glossary - Definition of terms FAQ - Frequently asked questions, and answers","title":"Documentation Sections"},{"location":"faq.html","text":"","title":"FAQ"},{"location":"getting_started.html","text":"Getting Started \u00b6 To get started, you'll first need to obtain a copy of the project by cloning the Git repo, or another method, if you haven't already done so. Then setup your build environment , and finally build the libraries, examples, tools and unit tests. Cloning The Project With Git \u00b6 Clone the project to a location in your filesystem, and update the submodules. For example, to clone the project in your home directory: macOS/Linux \u00b6 $ git clone https://github.com/Fitbit/golden-gate ~/golden-gate $ cd ~/golden-gate $ git submodule update --init --recursive Setting Up Your Build Environment \u00b6 Prerequisites \u00b6 macOS \u00b6 macOS is the recommended platform for working with Golden Gate, as it offers the most complete build environment, including the ability to build all targets, run all the examples, and can use the native Bluetooth support. On a mac running macOS 10.14 (Mojave) or higher, you will need to have at a minimum: XCode 11 or higher, including the command-line tools Homebrew - see Homebrew for installation instructions Miniconda (or Conda) - see Conda for macOS installation instructions With those prerequisites installed, you can initialize an environment for the Golden Gate project. In a shell window, from the top-level directory of the project, first install the homebrew packages by running $ brew bundle Then continue with the instructions for setting up a conda environment , below Linux \u00b6 A Linux host can be used to build all the targets, except iOS. On a Linux machine, you will need to have at a minimum: Git GCC and G++ ( build_essential package on Ubuntu or similar) Miniconda (or Conda) - see Conda for Linux installation instructions Docker \u00b6 If you have docker installed on your system, the project includes a Dockerfile that you can use to build a docker image. The resulting docker image contains the minimal set of tools needed to build the core libraries, examples, tests and docs. The easiest way to build the docker image is to use the invoke task (if you have installed invoke on your host system): $ inv docker.build You can also build it with other parameters, using the project's Dockerfile as input. Windows \u00b6 Under construction While the core library does compile and run on Windows, support for that platform is currently being re-factored. It isn't functional yet in the current release of the project. Setting Up a Conda Environment \u00b6 Now that you have conda , you can create a Conda environment. Conda is an open source package management system and environment management system that runs on Windows, macOS and Linux. Conda quickly installs, runs and updates packages and their dependencies. This project uses Conda to manage the installation and update of a number of tools and software components that are necessary for building and running the software. Create your conda environment by running $ conda env create -n gg This will create a conda environment named gg . Using a different environment name You can choose a different name for your environment if you wish. We use the name gg by default, but you can specify any other name you want when creating the environment by passing that name with the -n option of the conda env create command Once your environment is created (which you only need to do once), you can activate it by running $ conda activate gg Activate your gg environment anytime you want to work with the project. Once the environment is activated in a shell, all the tools that are needed to build and run the code are in your PATH . Updating you environment If you pull updated versions of the project, you should also update your gg environment (you don't need to re-create it every time) by running $ conda env update -n gg Smoke-testing your environment An easy way to do a basic test to check if your initial environment setup has worked, and has been activated, is to try a simple command like: $ inv -l which should list all the tasks that are available through the invoke task execution system, which you will use later to execute a number of tasks like building and running. Building \u00b6 The project uses the invoke task execution system to automate a number of tasks, including building the libraries and documentation, building and running tests, and more. Building For Your Host System \u00b6 Building for your host system is called a 'native' build. CMake is used to generate Makefiles and/or Ninja files (if the Ninja build system is installed on your system, which should be the case if you have correctly setup and activated your conda environment). Your host system could be a mac running macOS, a machine running Linux, or a virtual environment running in docker (use inv docker.run for an easy way to start a shell in a docker container, or use a custom invocation of docker with the docker image for the project, built as explained above). Run $ inv native.build to build all the core libraries, examples and unit tests for your host system. The output of the build can be found under xp/build/cmake/native . For example, you should be able to run $ xp/build/cmake/native/apps/stack-tool/gg-stack-tool and see the help for the gg-stack-tool command-line tool. And run $ inv native.test to execute all the unit tests and show the success/failure results. Using XCode on macOS \u00b6 If your host system is a mac, it is usually convenient to be able to build, run and debug from within XCode, rather than on the command line. This is the recommended way to work interactively with the project on a mac when you want to edit/compile/run/debug. There are two options available Generating An XCode Project Using CMake \u00b6 Start by generating the XCode project by running $ inv apple.macos.xp.gen This will generate an XCode project at xp/build/cmake/xcode-macOS/golden-gate-macos.xcodeproj . When you open that project file, you will find build targets for all the libraries, the command-line tools, the examples, and the unit tests. You can build, run and debug right from within XCode. Tip If you get a CMake error saying No CMAKE_C_COMPILER could be found , try $ sudo xcode-select -s /Applications/Xcode.app/Contents/Developer Using The Pre-generated XCode Project \u00b6 A hand-made XCode project is used to build the framework as well as the so-called \"Host Application\", which is a sample application that illustrates how to use some of the basic functionality offered by the framework. See the Building For iOS paragraph below for details, as the same project may be used for macOS as well as iOS. Building For Android \u00b6 See the Android Platform documentation for instructions on how to build the libraries, bindings and sample app for Android. Building For iOS \u00b6 See the iOS Platform documentation for instructions on how to build the libraries, bindings and sample app for iOS. Building For The Pylon Embedded Platform \u00b6 Pylon is the name used for the project's reference RTOS port. In the current version, the Pylon port is a MyNewt application running on a Nordic nRF52840 DK Development Kit . See the MyNewt Platform documentation for instructions on how to build the libraries, bindings and sample app for MyNewt. Building For The Espressif ESP32 Platform \u00b6 A basic port and sample Bluetooth peripheral application that can run on ESP32 processors is included. See the ESP32 Platform documentation for instructions on how to build the libraries and sample app for ESP32. Building For Other Platforms \u00b6 See the Platforms documentation for more details. Running Examples \u00b6 Depending on your host system, and what targets you have chosen to build, there are different ways to start running some of the examples. You can find a few typical example configurations below, but this is by no means exhaustive. Once you become familiar with the different targets and example apps, you can come up with many more ways to setup pairs of communicating endpoints. Also, you can start building your own applications and devices, then many more options are available to you. Host Only \u00b6 This is the simplest way to start running two instances of a Golden Gate stack on a single Mac or Linux host, without any dependency on a \"real\" transport like Bluetooth: you simply run two command line applications, each in its own shell on your host machine; the two applications communicate with each other using a local socket. See the Stack Tool documentation for some examples. macOS <-> Device \u00b6 If you have a Nordic nrf52840-DK Development Kit, you can build the Pylon gg-peripheral app and connect to it from your mac over Bluetooth. See Mynewt Apps for details on how to run and configure the gg-peripheral app on your board. Mobile <-> macOS \u00b6 If you have an iOS or Android phone, and want to try out one of the mobile Host Apps ( iOS Host App and Android Host App ) and a mac, you can run an instance of the Stack Tool on the mac, as a Peripheral (a.k.a Node in Golden Gate terminology), and use the Host App on your phone to connect to it. In addition you will run a CoAP server on your mac, that the Host App will make requests to, communicating through the stack tool. In a first Terminal window, run the CoAP server: $ gg-coap-server In a second Terminal window, run the stack tool in Node mode, configured to act as a Bluetooth peripheral, advertising under the name Jiji (the default name used by the stack tool), and forwarding CoAP requests to port 5683 on localhost. $ gg-stack-tool --top coap 127 .0.0.1 5683 5684 --bottom bluetooth node node DSNG Now, from either the iOS Host App or Android Host App, scan and find the mac that is advertising as Jiji , connect, and once the connection is established, send a CoAP request to /helloworld Mobile <-> Device \u00b6 If you have an iOS or Android phone, and want to try out one of the mobile Host Apps ( iOS Host App and Android Host App ), and a Nordic nrf52840-DK Development Kit, you can run the gg-peripheral app on your board and connect to it from your mobile app. Device <-> Device \u00b6 If you have a two Nordic nrf52840-DK Development Kits, you can build both the Pylon gg-central and gg-peripheral apps and connect one to the other. See Mynewt Apps for details on how to run and configure the gg-central and gg-peripheral apps on your board. What's Next? \u00b6 Start exploring the project, its architecture, components and APIs, and see how you can use the framework in your own applications and devices.","title":"Getting Started"},{"location":"getting_started.html#getting-started","text":"To get started, you'll first need to obtain a copy of the project by cloning the Git repo, or another method, if you haven't already done so. Then setup your build environment , and finally build the libraries, examples, tools and unit tests.","title":"Getting Started"},{"location":"getting_started.html#cloning-the-project-with-git","text":"Clone the project to a location in your filesystem, and update the submodules. For example, to clone the project in your home directory:","title":"Cloning The Project With Git"},{"location":"getting_started.html#macoslinux","text":"$ git clone https://github.com/Fitbit/golden-gate ~/golden-gate $ cd ~/golden-gate $ git submodule update --init --recursive","title":"macOS/Linux"},{"location":"getting_started.html#setting-up-your-build-environment","text":"","title":"Setting Up Your Build Environment"},{"location":"getting_started.html#prerequisites","text":"","title":"Prerequisites"},{"location":"getting_started.html#macos","text":"macOS is the recommended platform for working with Golden Gate, as it offers the most complete build environment, including the ability to build all targets, run all the examples, and can use the native Bluetooth support. On a mac running macOS 10.14 (Mojave) or higher, you will need to have at a minimum: XCode 11 or higher, including the command-line tools Homebrew - see Homebrew for installation instructions Miniconda (or Conda) - see Conda for macOS installation instructions With those prerequisites installed, you can initialize an environment for the Golden Gate project. In a shell window, from the top-level directory of the project, first install the homebrew packages by running $ brew bundle Then continue with the instructions for setting up a conda environment , below","title":"macOS"},{"location":"getting_started.html#linux","text":"A Linux host can be used to build all the targets, except iOS. On a Linux machine, you will need to have at a minimum: Git GCC and G++ ( build_essential package on Ubuntu or similar) Miniconda (or Conda) - see Conda for Linux installation instructions","title":"Linux"},{"location":"getting_started.html#docker","text":"If you have docker installed on your system, the project includes a Dockerfile that you can use to build a docker image. The resulting docker image contains the minimal set of tools needed to build the core libraries, examples, tests and docs. The easiest way to build the docker image is to use the invoke task (if you have installed invoke on your host system): $ inv docker.build You can also build it with other parameters, using the project's Dockerfile as input.","title":"Docker"},{"location":"getting_started.html#windows","text":"Under construction While the core library does compile and run on Windows, support for that platform is currently being re-factored. It isn't functional yet in the current release of the project.","title":"Windows"},{"location":"getting_started.html#setting-up-a-conda-environment","text":"Now that you have conda , you can create a Conda environment. Conda is an open source package management system and environment management system that runs on Windows, macOS and Linux. Conda quickly installs, runs and updates packages and their dependencies. This project uses Conda to manage the installation and update of a number of tools and software components that are necessary for building and running the software. Create your conda environment by running $ conda env create -n gg This will create a conda environment named gg . Using a different environment name You can choose a different name for your environment if you wish. We use the name gg by default, but you can specify any other name you want when creating the environment by passing that name with the -n option of the conda env create command Once your environment is created (which you only need to do once), you can activate it by running $ conda activate gg Activate your gg environment anytime you want to work with the project. Once the environment is activated in a shell, all the tools that are needed to build and run the code are in your PATH . Updating you environment If you pull updated versions of the project, you should also update your gg environment (you don't need to re-create it every time) by running $ conda env update -n gg Smoke-testing your environment An easy way to do a basic test to check if your initial environment setup has worked, and has been activated, is to try a simple command like: $ inv -l which should list all the tasks that are available through the invoke task execution system, which you will use later to execute a number of tasks like building and running.","title":"Setting Up a Conda Environment"},{"location":"getting_started.html#building","text":"The project uses the invoke task execution system to automate a number of tasks, including building the libraries and documentation, building and running tests, and more.","title":"Building"},{"location":"getting_started.html#building-for-your-host-system","text":"Building for your host system is called a 'native' build. CMake is used to generate Makefiles and/or Ninja files (if the Ninja build system is installed on your system, which should be the case if you have correctly setup and activated your conda environment). Your host system could be a mac running macOS, a machine running Linux, or a virtual environment running in docker (use inv docker.run for an easy way to start a shell in a docker container, or use a custom invocation of docker with the docker image for the project, built as explained above). Run $ inv native.build to build all the core libraries, examples and unit tests for your host system. The output of the build can be found under xp/build/cmake/native . For example, you should be able to run $ xp/build/cmake/native/apps/stack-tool/gg-stack-tool and see the help for the gg-stack-tool command-line tool. And run $ inv native.test to execute all the unit tests and show the success/failure results.","title":"Building For Your Host System"},{"location":"getting_started.html#using-xcode-on-macos","text":"If your host system is a mac, it is usually convenient to be able to build, run and debug from within XCode, rather than on the command line. This is the recommended way to work interactively with the project on a mac when you want to edit/compile/run/debug. There are two options available","title":"Using XCode on macOS"},{"location":"getting_started.html#generating-an-xcode-project-using-cmake","text":"Start by generating the XCode project by running $ inv apple.macos.xp.gen This will generate an XCode project at xp/build/cmake/xcode-macOS/golden-gate-macos.xcodeproj . When you open that project file, you will find build targets for all the libraries, the command-line tools, the examples, and the unit tests. You can build, run and debug right from within XCode. Tip If you get a CMake error saying No CMAKE_C_COMPILER could be found , try $ sudo xcode-select -s /Applications/Xcode.app/Contents/Developer","title":"Generating An XCode Project Using CMake"},{"location":"getting_started.html#using-the-pre-generated-xcode-project","text":"A hand-made XCode project is used to build the framework as well as the so-called \"Host Application\", which is a sample application that illustrates how to use some of the basic functionality offered by the framework. See the Building For iOS paragraph below for details, as the same project may be used for macOS as well as iOS.","title":"Using The Pre-generated XCode Project"},{"location":"getting_started.html#building-for-android","text":"See the Android Platform documentation for instructions on how to build the libraries, bindings and sample app for Android.","title":"Building For Android"},{"location":"getting_started.html#building-for-ios","text":"See the iOS Platform documentation for instructions on how to build the libraries, bindings and sample app for iOS.","title":"Building For iOS"},{"location":"getting_started.html#building-for-the-pylon-embedded-platform","text":"Pylon is the name used for the project's reference RTOS port. In the current version, the Pylon port is a MyNewt application running on a Nordic nRF52840 DK Development Kit . See the MyNewt Platform documentation for instructions on how to build the libraries, bindings and sample app for MyNewt.","title":"Building For The Pylon Embedded Platform"},{"location":"getting_started.html#building-for-the-espressif-esp32-platform","text":"A basic port and sample Bluetooth peripheral application that can run on ESP32 processors is included. See the ESP32 Platform documentation for instructions on how to build the libraries and sample app for ESP32.","title":"Building For The Espressif ESP32 Platform"},{"location":"getting_started.html#building-for-other-platforms","text":"See the Platforms documentation for more details.","title":"Building For Other Platforms"},{"location":"getting_started.html#running-examples","text":"Depending on your host system, and what targets you have chosen to build, there are different ways to start running some of the examples. You can find a few typical example configurations below, but this is by no means exhaustive. Once you become familiar with the different targets and example apps, you can come up with many more ways to setup pairs of communicating endpoints. Also, you can start building your own applications and devices, then many more options are available to you.","title":"Running Examples"},{"location":"getting_started.html#host-only","text":"This is the simplest way to start running two instances of a Golden Gate stack on a single Mac or Linux host, without any dependency on a \"real\" transport like Bluetooth: you simply run two command line applications, each in its own shell on your host machine; the two applications communicate with each other using a local socket. See the Stack Tool documentation for some examples.","title":"Host Only"},{"location":"getting_started.html#macos-device","text":"If you have a Nordic nrf52840-DK Development Kit, you can build the Pylon gg-peripheral app and connect to it from your mac over Bluetooth. See Mynewt Apps for details on how to run and configure the gg-peripheral app on your board.","title":"macOS &lt;-&gt; Device"},{"location":"getting_started.html#mobile-macos","text":"If you have an iOS or Android phone, and want to try out one of the mobile Host Apps ( iOS Host App and Android Host App ) and a mac, you can run an instance of the Stack Tool on the mac, as a Peripheral (a.k.a Node in Golden Gate terminology), and use the Host App on your phone to connect to it. In addition you will run a CoAP server on your mac, that the Host App will make requests to, communicating through the stack tool. In a first Terminal window, run the CoAP server: $ gg-coap-server In a second Terminal window, run the stack tool in Node mode, configured to act as a Bluetooth peripheral, advertising under the name Jiji (the default name used by the stack tool), and forwarding CoAP requests to port 5683 on localhost. $ gg-stack-tool --top coap 127 .0.0.1 5683 5684 --bottom bluetooth node node DSNG Now, from either the iOS Host App or Android Host App, scan and find the mac that is advertising as Jiji , connect, and once the connection is established, send a CoAP request to /helloworld","title":"Mobile &lt;-&gt; macOS"},{"location":"getting_started.html#mobile-device","text":"If you have an iOS or Android phone, and want to try out one of the mobile Host Apps ( iOS Host App and Android Host App ), and a Nordic nrf52840-DK Development Kit, you can run the gg-peripheral app on your board and connect to it from your mobile app.","title":"Mobile &lt;-&gt; Device"},{"location":"getting_started.html#device-device","text":"If you have a two Nordic nrf52840-DK Development Kits, you can build both the Pylon gg-central and gg-peripheral apps and connect one to the other. See Mynewt Apps for details on how to run and configure the gg-central and gg-peripheral apps on your board.","title":"Device &lt;-&gt; Device"},{"location":"getting_started.html#whats-next","text":"Start exploring the project, its architecture, components and APIs, and see how you can use the framework in your own applications and devices.","title":"What's Next?"},{"location":"glossary.html","text":"Term Definition XP Cross Platform Gattlink Bidirectional streaming protocol over GATT CoAP Constrained Application Protocol - RFC7252 BLE Bluetooth Low Energy GATT The Generic Attributes specification that defines a hierarchical data structure exposed to connected Bluetooth Low Energy devices.","title":"Glossary"},{"location":"introduction.html","text":"Introduction to the Golden Gate Project \u00b6 Project Goals \u00b6 The goal of the Golden Gate project is to allow implementers of embedded devices to communicate with remote (typically mobile) applications in a way that looks and feels like the way they would do it in a traditional networked environment, where the de-facto standard is to use web technologies like TCP/IP for transport, TLS for security, HTTP for applications, and other familiar protocols. The challenge that the Golden Gate project is taking on is to offer the familiarity and ease-of-use of those well established web technologies on platforms where those technologies are not directly available from the underlying operating system, but where other communication mechanisms may exist. The most common case is a mobile phone communicating with an embedded device, like a wearable or IoT device, over BLE (Bluetooth Low Energy). While the services offered by iOS and Android phones may eventually evolve to a model where TCP/IP is transparently offered over BLE, the situation today is that what mobile applications are given is limited to the GATT protocol, which may be well suited for very simple tasks like exposing small values, such as the reading from a heart rate or temperature sensor, but far from being a flexible transport channel like an HTTP or Web Socket connection. Furthermore, targeting devices with constrained resources, where flash code space and runtime memory is a few tens of KBs, and CPU speeds are often below 100MHz, means that a highly optimized implementation is required, so as to not overly limit the richness of the functionality, security, maintainability, and robustness while staying withing strict limits. Finally, a secondary goal is to be able to share the bulk of the implementation across widely different platforms, and integrate seamlessly in applications that written in diverse programming languages on a number of distinct operating systems. Network Stack Approach \u00b6 The approach taken by Golden Gate to reach that goal is to implement a core library that offers a complete network stack, with cleanly separated layers that leverage well established standards. On top of the stack are the applications and services that make or receive requests. For application requests, the first supported protocol is CoAP. CoAP is a lightweight application protocol optimized for constrained devices. Other protocols, such as HTTP and WebSocket messages, may be implemented in future versions. The requests transit through the network stack, all the way to the bottom of the stack, where a physical transport layer is used to communicate with a remote, peer application or service. On the peer is an equivalent stack that the requests traverses in the reverse direction, all the way to that peer's own set of applications and services. The responses take the reverse route all the way back to the original client application. Note In this diagram, the translucent boxes represent elements of the stack that are not yet implemented in version 1 of the framework Applications & Services \u00b6 Applications, in this context, are protocol clients that send requests to services hosted on a peer device, from which they receive responses. CoAP \u00b6 CoAP is an internet technology standard defined in RFC7252 . It offers a request/response protocol very similar to HTTP, but with a lower processing overhead and the ability to be transported over UDP instead of TCP. It has builtin support for reliability (even though UDP itself does not offer that), and well-defined semantics that are very close to what developers may be used to with HTTP, such as GET , PUT , POST and DELETE methods, request and response headers (\"options\" in CoAP terminology), numeric response status codes that map 1-1 with HTTP response status codes, and more. As such, developing a rich set of interactions over CoAP is very straightforward, without a steep learning curve. Core Library \u00b6 The core library is where all the software modules needed for the layers of the stack, as well as the runtime needed by those modules, application and services, are implemented, in C. The most important modules are: Module Description common Portable runtime (memory, lists, strings, etc.) loop Loop object for scheduling asynchronous non-blocking functions coap Full-features CoAP client and server library lwip Integration of the LwIP IP stack, which may be used on platforms that don't have their own IP stacks netif Network interface modules that can be registered with the IP stacks sockets Network sockets abstraction that works with the I/O model tls DTLS protocol gattlink Gattlink protocol protocols Protocol-related functionality, like IP header compression, etc. stack_builder Builder object that knows how to create and connect layers of a protocol stack based on a dynamic configuration remote Support for test automation services Collection of services, such as performance/throughput testing smo Simple object model that can model CBOR or JSON-like objects, including a CBOR parser/serializer utils Various utilities IP \u00b6 The choice of IP is an important choice made for the project, as it is the de-facto standard for most network communication on the internet. It not only gives this project a seamless way to integrate with other systems, but also allows the reuse of a large number of well-known, proven, robust associated protocols, such as (D)TLS, and of a wide range of vendor-supported or open-source software components when appropriate. Golden Gate can be configured to work with a platform's existing IP stack, when that is desirable, and/or may be configured to embed its own IP stack (for which there are two flavors included in the project: one based on the popular LwIP stack, the other a tiny UDP-only stack for cases where code size is severely constrained). Language Bindings \u00b6 While the core library is written in C, and may be used as-is, through its native C API, on all platforms, it is not expected that developers writing applications and services on operating systems where C is not a common programming language would use that API directly. Instead, Golden Gate includes language-specific bindings that offer APIs for other languages that look and feel idiomatic to those languages, and make the right calls to the C API under the hood, transparently to the developer. For iOS applications, there are Swift bindings. The Swift bindings go through the automatic Swift/C bridge supported by the Apple developer platform. For Android applications, there are Kotlin bindings, which go through JNI to interact with the core library. Build System \u00b6 In order to be buildable for a wide range of target platforms, the Golden Gate project is structured in a way that makes it easy to: Compile natively on a host platform targeting itself (macOS, Linux, Windows) Cross-compile for a target platform that allows the library to be compiled against a platform SDK (for example iOS, Android, embedded Linux) Cross-compile as a component from within a platform's build system (for example, Zephyr, NuttX, ESP-IDF) The build system is based on CMake, which can generate build instructions for a variety of build systems, and integrates very well with development environments like Android Studio, Microsoft Visual Studio, and many embedded development platforms like Zephyr and ESP-IDF. Tools and Applications \u00b6 The project includes a number of useful tools and applications that either use the core library, or are designed to work or interact with applications and services that use the library. Host Applications \u00b6 Two important applications included in the project are the iOS and Android so-called Host Applications . Those are very simple applications, without bells and whistle, that illustrate how to use the Golden Gate framework in an application. They allow scanning for devices, connecting, setting up a protocol stack, and include an example CoAP client and server. Embedded Application for Reference Hardware \u00b6 To provide a simple, easy-to-understand example of an embedded application that can communicate with one of the mobile host applications, the project includes a sample application for the MyNewt RTOS , which is configured to run on off-the-shelf nrf52840-DK development boards, which can be obtained online for a few dollars. That sample application can be configured to run as a BLE master or slave (playing the roles of Hub or Node in Golden Gate terminology). Stack Tool \u00b6 The Stack Tool is a command-line application that can be run on Linux, macOS or Windows. It hosts any configuration of a Golden Gate protocol stack, connecting the top and bottom of the stack to a native UDP socket (or directly to Bluetooth on macOS). This allows running CoAP clients and servers, written in any language, with any CoAP library, going through the stack running in the stack tool process, all the way to a peer device running a compatible stack. This makes rapid development and prototyping of CoAP clients and servers very easy, and lets your implement simulators or test implementations of the business logic of your applications and services without necessarily having the final target platforms up and running. Support for Test Automation \u00b6","title":"Introduction"},{"location":"introduction.html#introduction-to-the-golden-gate-project","text":"","title":"Introduction to the Golden Gate Project"},{"location":"introduction.html#project-goals","text":"The goal of the Golden Gate project is to allow implementers of embedded devices to communicate with remote (typically mobile) applications in a way that looks and feels like the way they would do it in a traditional networked environment, where the de-facto standard is to use web technologies like TCP/IP for transport, TLS for security, HTTP for applications, and other familiar protocols. The challenge that the Golden Gate project is taking on is to offer the familiarity and ease-of-use of those well established web technologies on platforms where those technologies are not directly available from the underlying operating system, but where other communication mechanisms may exist. The most common case is a mobile phone communicating with an embedded device, like a wearable or IoT device, over BLE (Bluetooth Low Energy). While the services offered by iOS and Android phones may eventually evolve to a model where TCP/IP is transparently offered over BLE, the situation today is that what mobile applications are given is limited to the GATT protocol, which may be well suited for very simple tasks like exposing small values, such as the reading from a heart rate or temperature sensor, but far from being a flexible transport channel like an HTTP or Web Socket connection. Furthermore, targeting devices with constrained resources, where flash code space and runtime memory is a few tens of KBs, and CPU speeds are often below 100MHz, means that a highly optimized implementation is required, so as to not overly limit the richness of the functionality, security, maintainability, and robustness while staying withing strict limits. Finally, a secondary goal is to be able to share the bulk of the implementation across widely different platforms, and integrate seamlessly in applications that written in diverse programming languages on a number of distinct operating systems.","title":"Project Goals"},{"location":"introduction.html#network-stack-approach","text":"The approach taken by Golden Gate to reach that goal is to implement a core library that offers a complete network stack, with cleanly separated layers that leverage well established standards. On top of the stack are the applications and services that make or receive requests. For application requests, the first supported protocol is CoAP. CoAP is a lightweight application protocol optimized for constrained devices. Other protocols, such as HTTP and WebSocket messages, may be implemented in future versions. The requests transit through the network stack, all the way to the bottom of the stack, where a physical transport layer is used to communicate with a remote, peer application or service. On the peer is an equivalent stack that the requests traverses in the reverse direction, all the way to that peer's own set of applications and services. The responses take the reverse route all the way back to the original client application. Note In this diagram, the translucent boxes represent elements of the stack that are not yet implemented in version 1 of the framework","title":"Network Stack Approach"},{"location":"introduction.html#applications-services","text":"Applications, in this context, are protocol clients that send requests to services hosted on a peer device, from which they receive responses.","title":"Applications &amp; Services"},{"location":"introduction.html#coap","text":"CoAP is an internet technology standard defined in RFC7252 . It offers a request/response protocol very similar to HTTP, but with a lower processing overhead and the ability to be transported over UDP instead of TCP. It has builtin support for reliability (even though UDP itself does not offer that), and well-defined semantics that are very close to what developers may be used to with HTTP, such as GET , PUT , POST and DELETE methods, request and response headers (\"options\" in CoAP terminology), numeric response status codes that map 1-1 with HTTP response status codes, and more. As such, developing a rich set of interactions over CoAP is very straightforward, without a steep learning curve.","title":"CoAP"},{"location":"introduction.html#core-library","text":"The core library is where all the software modules needed for the layers of the stack, as well as the runtime needed by those modules, application and services, are implemented, in C. The most important modules are: Module Description common Portable runtime (memory, lists, strings, etc.) loop Loop object for scheduling asynchronous non-blocking functions coap Full-features CoAP client and server library lwip Integration of the LwIP IP stack, which may be used on platforms that don't have their own IP stacks netif Network interface modules that can be registered with the IP stacks sockets Network sockets abstraction that works with the I/O model tls DTLS protocol gattlink Gattlink protocol protocols Protocol-related functionality, like IP header compression, etc. stack_builder Builder object that knows how to create and connect layers of a protocol stack based on a dynamic configuration remote Support for test automation services Collection of services, such as performance/throughput testing smo Simple object model that can model CBOR or JSON-like objects, including a CBOR parser/serializer utils Various utilities","title":"Core Library"},{"location":"introduction.html#ip","text":"The choice of IP is an important choice made for the project, as it is the de-facto standard for most network communication on the internet. It not only gives this project a seamless way to integrate with other systems, but also allows the reuse of a large number of well-known, proven, robust associated protocols, such as (D)TLS, and of a wide range of vendor-supported or open-source software components when appropriate. Golden Gate can be configured to work with a platform's existing IP stack, when that is desirable, and/or may be configured to embed its own IP stack (for which there are two flavors included in the project: one based on the popular LwIP stack, the other a tiny UDP-only stack for cases where code size is severely constrained).","title":"IP"},{"location":"introduction.html#language-bindings","text":"While the core library is written in C, and may be used as-is, through its native C API, on all platforms, it is not expected that developers writing applications and services on operating systems where C is not a common programming language would use that API directly. Instead, Golden Gate includes language-specific bindings that offer APIs for other languages that look and feel idiomatic to those languages, and make the right calls to the C API under the hood, transparently to the developer. For iOS applications, there are Swift bindings. The Swift bindings go through the automatic Swift/C bridge supported by the Apple developer platform. For Android applications, there are Kotlin bindings, which go through JNI to interact with the core library.","title":"Language Bindings"},{"location":"introduction.html#build-system","text":"In order to be buildable for a wide range of target platforms, the Golden Gate project is structured in a way that makes it easy to: Compile natively on a host platform targeting itself (macOS, Linux, Windows) Cross-compile for a target platform that allows the library to be compiled against a platform SDK (for example iOS, Android, embedded Linux) Cross-compile as a component from within a platform's build system (for example, Zephyr, NuttX, ESP-IDF) The build system is based on CMake, which can generate build instructions for a variety of build systems, and integrates very well with development environments like Android Studio, Microsoft Visual Studio, and many embedded development platforms like Zephyr and ESP-IDF.","title":"Build System"},{"location":"introduction.html#tools-and-applications","text":"The project includes a number of useful tools and applications that either use the core library, or are designed to work or interact with applications and services that use the library.","title":"Tools and Applications"},{"location":"introduction.html#host-applications","text":"Two important applications included in the project are the iOS and Android so-called Host Applications . Those are very simple applications, without bells and whistle, that illustrate how to use the Golden Gate framework in an application. They allow scanning for devices, connecting, setting up a protocol stack, and include an example CoAP client and server.","title":"Host Applications"},{"location":"introduction.html#embedded-application-for-reference-hardware","text":"To provide a simple, easy-to-understand example of an embedded application that can communicate with one of the mobile host applications, the project includes a sample application for the MyNewt RTOS , which is configured to run on off-the-shelf nrf52840-DK development boards, which can be obtained online for a few dollars. That sample application can be configured to run as a BLE master or slave (playing the roles of Hub or Node in Golden Gate terminology).","title":"Embedded Application for Reference Hardware"},{"location":"introduction.html#stack-tool","text":"The Stack Tool is a command-line application that can be run on Linux, macOS or Windows. It hosts any configuration of a Golden Gate protocol stack, connecting the top and bottom of the stack to a native UDP socket (or directly to Bluetooth on macOS). This allows running CoAP clients and servers, written in any language, with any CoAP library, going through the stack running in the stack tool process, all the way to a peer device running a compatible stack. This makes rapid development and prototyping of CoAP clients and servers very easy, and lets your implement simulators or test implementations of the business logic of your applications and services without necessarily having the final target platforms up and running.","title":"Stack Tool"},{"location":"introduction.html#support-for-test-automation","text":"","title":"Support for Test Automation"},{"location":"license.html","text":"PLACEHOLDER","title":"License"},{"location":"release_notes.html","text":"","title":"Release Notes"},{"location":"sample.html","text":"Example MkDoc Usage \u00b6 Syntax Highlighting \u00b6 static void foobar ( int x , const char * y ); Admonitions \u00b6 See: https://squidfunk.github.io/mkdocs-material/extensions/admonition Some Note Title This is a Note admonition Note This is a Note admonition without a title This is a Note admonition with an empty title Info This is an Info admonition Tip This is a Tip admonition Hint This is a Hint admonition Warning This is a Warning admonition Caution This is a Caution admonition Abstract This is an Abstract admonition Success This is a Success admonition Failure This is a Failure admonition Danger This is a Danger admonition Bug This is a Bug admonition Example This is an Example admonition Question This is a Question admonition Settings This is a Settings admonition Quote This is a Quote admonition Collapsible admonitions \u00b6 ( needs the details extension from pymdown-extensions) Some FAQ question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Example MkDoc Usage"},{"location":"sample.html#example-mkdoc-usage","text":"","title":"Example MkDoc Usage"},{"location":"sample.html#syntax-highlighting","text":"static void foobar ( int x , const char * y );","title":"Syntax Highlighting"},{"location":"sample.html#admonitions","text":"See: https://squidfunk.github.io/mkdocs-material/extensions/admonition Some Note Title This is a Note admonition Note This is a Note admonition without a title This is a Note admonition with an empty title Info This is an Info admonition Tip This is a Tip admonition Hint This is a Hint admonition Warning This is a Warning admonition Caution This is a Caution admonition Abstract This is an Abstract admonition Success This is a Success admonition Failure This is a Failure admonition Danger This is a Danger admonition Bug This is a Bug admonition Example This is an Example admonition Question This is a Question admonition Settings This is a Settings admonition Quote This is a Quote admonition","title":"Admonitions"},{"location":"sample.html#collapsible-admonitions","text":"( needs the details extension from pymdown-extensions) Some FAQ question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Collapsible admonitions"},{"location":"api/index.html","text":"API Documentation \u00b6 The project offers 3 main APIs. At the core is the C API for all the functionality exposed by the cross-platform library. The C API is available on all platforms. In addition, there is a Swift API for iOS, and a Kotlin API for Android. Those APIs offer a more language-idiomatic access to the same functionality that may otherwise be accessed through the C API, which is much more convenient for mobile developers. Documentation Sections \u00b6 C API Swift API Kotlin API","title":"Overview"},{"location":"api/index.html#api-documentation","text":"The project offers 3 main APIs. At the core is the C API for all the functionality exposed by the cross-platform library. The C API is available on all platforms. In addition, there is a Swift API for iOS, and a Kotlin API for Android. Those APIs offer a more language-idiomatic access to the same functionality that may otherwise be accessed through the C API, which is much more convenient for mobile developers.","title":"API Documentation"},{"location":"api/index.html#documentation-sections","text":"C API Swift API Kotlin API","title":"Documentation Sections"},{"location":"api/c_api.html","text":"Doxygen Documentation \u00b6 Browse through the C API Doxygen-generated documentation","title":"C API Reference"},{"location":"api/c_api.html#doxygen-documentation","text":"Browse through the C API Doxygen-generated documentation","title":"Doxygen Documentation"},{"location":"api/kotlin_api.html","text":"Kotlin API \u00b6 The Kotlin API offers Kotlin language bindings for the functionality implemented by the core library. The bindings are written as a combination of Kotlin code and JNI C/C++ code. While it is always possible to directly reach all the C functions through JNI on Android, it is recommended to use the Kotlin bindings whenever possible. Click through the packages below to view documentation for the different packages. If you want to send or receive a message over Golden Gate, you're probably most interested in the bindings.coap package, specifically the Endpoint interface. Golden Gate Bindings Package \u00b6 Browse through the Kdoc-generated documentation Golden Gate Connection Manager Package \u00b6 Browse through the Kdoc-generated documentation RX FibitGatt Package \u00b6 Reactive API on top of the bitgatt API Browse through the Kdoc-generated documentation","title":"Kotlin API Reference"},{"location":"api/kotlin_api.html#kotlin-api","text":"The Kotlin API offers Kotlin language bindings for the functionality implemented by the core library. The bindings are written as a combination of Kotlin code and JNI C/C++ code. While it is always possible to directly reach all the C functions through JNI on Android, it is recommended to use the Kotlin bindings whenever possible. Click through the packages below to view documentation for the different packages. If you want to send or receive a message over Golden Gate, you're probably most interested in the bindings.coap package, specifically the Endpoint interface.","title":"Kotlin API"},{"location":"api/kotlin_api.html#golden-gate-bindings-package","text":"Browse through the Kdoc-generated documentation","title":"Golden Gate Bindings Package"},{"location":"api/kotlin_api.html#golden-gate-connection-manager-package","text":"Browse through the Kdoc-generated documentation","title":"Golden Gate Connection Manager Package"},{"location":"api/kotlin_api.html#rx-fibitgatt-package","text":"Reactive API on top of the bitgatt API Browse through the Kdoc-generated documentation","title":"RX FibitGatt Package"},{"location":"api/swift_api.html","text":"Swift API \u00b6 To be added API docs to be added. In the meantime, consult the source files and sample application","title":"Swift API Reference"},{"location":"api/swift_api.html#swift-api","text":"To be added API docs to be added. In the meantime, consult the source files and sample application","title":"Swift API"},{"location":"apps/index.html","text":"Sample Apps \u00b6 Mobile Host Apps \u00b6 Mobile Host Apps are very simple sample apps that you can run on a mobile phone or tablet. These apps allow you to scan for and connect to compatible devices, phones or desktops, running a peer Golden Gate-based app. The Host Apps can be configured to different stack configurations. Once connected, a few simple operations are possible, including sending test CoAP requests, and performing a 'blast' throughput test. There is a Host App for Android and a Host App for iOS MyNewt Sample Apps \u00b6 Two sample applications, which share a lot in common, are available for the reference MyNewt port (a.k.a \"Pylon\"): gg-peripheral - a simple MyNewt application that configures the board to power-on bluetooth and advertise as a Peripheral (a.k.a Node in the Golden Gate topology). gg-central - a simple MyNewt application that configures the board to power-on bluetooth as a Central (a.k.a Hub in the Golden Gate topology) Both apps offer similar functionality, including a command-line interface to configure logging, the stack, and start/stop operations. See MyNewt Apps for details.","title":"Apps"},{"location":"apps/index.html#sample-apps","text":"","title":"Sample Apps"},{"location":"apps/index.html#mobile-host-apps","text":"Mobile Host Apps are very simple sample apps that you can run on a mobile phone or tablet. These apps allow you to scan for and connect to compatible devices, phones or desktops, running a peer Golden Gate-based app. The Host Apps can be configured to different stack configurations. Once connected, a few simple operations are possible, including sending test CoAP requests, and performing a 'blast' throughput test. There is a Host App for Android and a Host App for iOS","title":"Mobile Host Apps"},{"location":"apps/index.html#mynewt-sample-apps","text":"Two sample applications, which share a lot in common, are available for the reference MyNewt port (a.k.a \"Pylon\"): gg-peripheral - a simple MyNewt application that configures the board to power-on bluetooth and advertise as a Peripheral (a.k.a Node in the Golden Gate topology). gg-central - a simple MyNewt application that configures the board to power-on bluetooth as a Central (a.k.a Hub in the Golden Gate topology) Both apps offer similar functionality, including a command-line interface to configure logging, the stack, and start/stop operations. See MyNewt Apps for details.","title":"MyNewt Sample Apps"},{"location":"apps/android/host_app.html","text":"Android Host App \u00b6 The Android Host App is a simple app that offers a very basic user interface to allow scanning, connecting to and interacting with another device or app over Bluetooth. Screens \u00b6 Main Screen \u00b6 This screen is what you see when you launch the app. On that screen, select a stack configuration from the \"Stack Configuration\" choices, and a service type from the \"Stack Service\" choices. Danger Don't change the IP Address values, unless you know exactly what you're doing and you have a specific need to do that. The default values are what you need in almost all cases. Scan Screen \u00b6 The \"Scan\" screen allows you to scan for compatible devices that are advertising. Each device appears in a list with its advertised name and signal strength. To select a device to pair with, just tap on its entry in the list. Interaction Screen \u00b6 The \"Interaction\" screen allows you to interact with a connected peer. When using the CoAP service mode, you can send a CoAP request to the peer. When using the Blast service mode, you can start/stop the performance test blast with the peer.","title":"Android Host App"},{"location":"apps/android/host_app.html#android-host-app","text":"The Android Host App is a simple app that offers a very basic user interface to allow scanning, connecting to and interacting with another device or app over Bluetooth.","title":"Android Host App"},{"location":"apps/android/host_app.html#screens","text":"","title":"Screens"},{"location":"apps/android/host_app.html#main-screen","text":"This screen is what you see when you launch the app. On that screen, select a stack configuration from the \"Stack Configuration\" choices, and a service type from the \"Stack Service\" choices. Danger Don't change the IP Address values, unless you know exactly what you're doing and you have a specific need to do that. The default values are what you need in almost all cases.","title":"Main Screen"},{"location":"apps/android/host_app.html#scan-screen","text":"The \"Scan\" screen allows you to scan for compatible devices that are advertising. Each device appears in a list with its advertised name and signal strength. To select a device to pair with, just tap on its entry in the list.","title":"Scan Screen"},{"location":"apps/android/host_app.html#interaction-screen","text":"The \"Interaction\" screen allows you to interact with a connected peer. When using the CoAP service mode, you can send a CoAP request to the peer. When using the Blast service mode, you can start/stop the performance test blast with the peer.","title":"Interaction Screen"},{"location":"apps/ios/host_app.html","text":"iOS Host App \u00b6 The iOS Host App is a simple app that offers a very basic user interface to allow scanning, connecting to and interacting with another device or app over Bluetooth. Screens \u00b6 Main Screen \u00b6 This screen is what you see when you launch the app. It shows some of the build configuration information, and a \"Paired Peers\" navigation button that takes you to the \"Paired Peers\" screen. Paired Peers Screen \u00b6 This screen shows a list of paired peers and their status. You can add a peer to the list by tapping the button. You can tap the button to go to the \"Peer\" screen and interact with the peer. Note The term \"paired\" here doesn't refer to Bluetooth pairing and bonding, it just means that it is a peer that has been found and saved in a list of peers Peer Screen \u00b6 This screen allows you to configure the stack used to communicate with the peer, and see some of the parameters of the current connection. The \"Stack\" navigation button is used to navigate to a screen where you can select the stack configuration you want. The \"Services\" navigation button takes you to the \"Services\" screen where you can select what services will be connected through the stack. The \"Connect\" toggle can be used to connect to / disconnect from the peer. Note Any change in stack configuration or service type must be done prior to connecting. Once connected, those cannot change. Services Screen \u00b6 This screen allows you to interact with the peer. Depending on the service that you have selected. Use the \"Service\" navigation button to select between: None - no service (the stack is configured, but no service is attached to it) CoAP - a CoAP server and client are attached to the stack Blasting - a \"blast\" performance test service is attached to the stack CoAP \u00b6 When the selected service is \"CoAP\", the COAP section of the screen allows you to send a CoAP request to the peer, and any response received back will be displayed in a popup. Blast \u00b6 When the selected service is \"Blast\", the \"Blast\" toggle can be used to start/stop blasting packets to a blast receiver. The \"Packet Size\" option lets you select the packet size when blasting, from 30 bytes to 1000 bytes. Stack Screen \u00b6 This screen lets you select the stack configuration you want. The available stack configurations are: G - Just Gattlink NG - Same as G + Network Interface SNG - Same as NG + UDP Socket DSNG - Same as SNG + DTLS DSNGA - Same as DSNG + Traffic Analyzer (default choice) Pair Screen \u00b6 The \"Pair\" screen allows you to scan for compatible devices that are advertising. Each device appears in a list with its advertised name and signal strength. To select a device to pair with, just tap on its entry in the list.","title":"iOS Host App"},{"location":"apps/ios/host_app.html#ios-host-app","text":"The iOS Host App is a simple app that offers a very basic user interface to allow scanning, connecting to and interacting with another device or app over Bluetooth.","title":"iOS Host App"},{"location":"apps/ios/host_app.html#screens","text":"","title":"Screens"},{"location":"apps/ios/host_app.html#main-screen","text":"This screen is what you see when you launch the app. It shows some of the build configuration information, and a \"Paired Peers\" navigation button that takes you to the \"Paired Peers\" screen.","title":"Main Screen"},{"location":"apps/ios/host_app.html#paired-peers-screen","text":"This screen shows a list of paired peers and their status. You can add a peer to the list by tapping the button. You can tap the button to go to the \"Peer\" screen and interact with the peer. Note The term \"paired\" here doesn't refer to Bluetooth pairing and bonding, it just means that it is a peer that has been found and saved in a list of peers","title":"Paired Peers Screen"},{"location":"apps/ios/host_app.html#peer-screen","text":"This screen allows you to configure the stack used to communicate with the peer, and see some of the parameters of the current connection. The \"Stack\" navigation button is used to navigate to a screen where you can select the stack configuration you want. The \"Services\" navigation button takes you to the \"Services\" screen where you can select what services will be connected through the stack. The \"Connect\" toggle can be used to connect to / disconnect from the peer. Note Any change in stack configuration or service type must be done prior to connecting. Once connected, those cannot change.","title":"Peer Screen"},{"location":"apps/ios/host_app.html#services-screen","text":"This screen allows you to interact with the peer. Depending on the service that you have selected. Use the \"Service\" navigation button to select between: None - no service (the stack is configured, but no service is attached to it) CoAP - a CoAP server and client are attached to the stack Blasting - a \"blast\" performance test service is attached to the stack","title":"Services Screen"},{"location":"apps/ios/host_app.html#coap","text":"When the selected service is \"CoAP\", the COAP section of the screen allows you to send a CoAP request to the peer, and any response received back will be displayed in a popup.","title":"CoAP"},{"location":"apps/ios/host_app.html#blast","text":"When the selected service is \"Blast\", the \"Blast\" toggle can be used to start/stop blasting packets to a blast receiver. The \"Packet Size\" option lets you select the packet size when blasting, from 30 bytes to 1000 bytes.","title":"Blast"},{"location":"apps/ios/host_app.html#stack-screen","text":"This screen lets you select the stack configuration you want. The available stack configurations are: G - Just Gattlink NG - Same as G + Network Interface SNG - Same as NG + UDP Socket DSNG - Same as SNG + DTLS DSNGA - Same as DSNG + Traffic Analyzer (default choice)","title":"Stack Screen"},{"location":"apps/ios/host_app.html#pair-screen","text":"The \"Pair\" screen allows you to scan for compatible devices that are advertising. Each device appears in a list with its advertised name and signal strength. To select a device to pair with, just tap on its entry in the list.","title":"Pair Screen"},{"location":"apps/mynewt/mynewt_apps.html","text":"","title":"MyNewt Apps"},{"location":"architecture/index.html","text":"Architecture & Technical Specifications \u00b6 Documentation Sections \u00b6 Software Architecture - Details about the architecture of the software Gattlink - Details about the Gattlink protocol Security - Details about how the communications are authenticated and encrypted","title":"Overview"},{"location":"architecture/index.html#architecture-technical-specifications","text":"","title":"Architecture &amp; Technical Specifications"},{"location":"architecture/index.html#documentation-sections","text":"Software Architecture - Details about the architecture of the software Gattlink - Details about the Gattlink protocol Security - Details about how the communications are authenticated and encrypted","title":"Documentation Sections"},{"location":"architecture/gattlink.html","text":"Gattlink Protocol \u00b6 Protocol in a nutshell Control Packets Used for handshake or reset during a session Each peer sends a RESET packet with parameters and waits for a reset ACK Parameters include version and window size Timers for retries Session - Data Packets A packet has data only, ACK only, or both data and ACK Packets with data have a Packet Sequence Number ( PSN ) ACKs acknowledge the receipt of \"up to\" a PSN ACKs are sent when 1/2 or more of the window needs ACK'ing, or a certain time passes (default 200ms) Packets are resent when not ACK'ed for some time (default 4 seconds) Consecutive missed ACKs = stall. Stall event emitted GattLink Buffers \u00b6","title":"Gattlink"},{"location":"architecture/gattlink.html#gattlink-protocol","text":"Protocol in a nutshell Control Packets Used for handshake or reset during a session Each peer sends a RESET packet with parameters and waits for a reset ACK Parameters include version and window size Timers for retries Session - Data Packets A packet has data only, ACK only, or both data and ACK Packets with data have a Packet Sequence Number ( PSN ) ACKs acknowledge the receipt of \"up to\" a PSN ACKs are sent when 1/2 or more of the window needs ACK'ing, or a certain time passes (default 200ms) Packets are resent when not ACK'ed for some time (default 4 seconds) Consecutive missed ACKs = stall. Stall event emitted","title":"Gattlink Protocol"},{"location":"architecture/gattlink.html#gattlink-buffers","text":"","title":"GattLink Buffers"},{"location":"architecture/loop.html","text":"Loop \u00b6","title":"Loop"},{"location":"architecture/loop.html#loop","text":"","title":"Loop"},{"location":"architecture/security.html","text":"Security \u00b6 Golden Gate supports secure end-to-end communications over its protocol stack. In the standard configuration, a protocol stack includes as the next layer after the CoAP application protocol a DTLS layer. DTLS \u00b6 DTLS is defined in RFC6347 . It is essentially a variant of TLS that is designed to work with UDP datagrams instead of TCP streams. Cipher Suites \u00b6 The library can be configured to support any cipher suite that is supported by the DTLS engine that is selected at build time. In the current version, the only DTLS engine support is MbedTLS, which supports an impressive range of cipher suites. In practices, when deployed on small devices, the DTLS engine is configured with a small subset of all the supported cipher suite. The standard configuration chosen is to enable the following cipher suites: TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 TLS_PSK_WITH_AES_128_CCM TLS_PSK_WITH_AES_128_GCM_SHA256 The choice of PSK here is key to keeping the DTLS handshake simple and lightweight for small devices, avoiding complex PKI certificate processing. Client and Server Roles \u00b6 In the Golden Gate network topology, the stack running in the mobile application is configured to be in the so-called Hub role, in which case its DTLS protocol layer is a DTLS server. Conversely, the embedded device to which the mobile application connects is configured to be in the so-called Node role, in which case its DTLS protocol layer is a DTLS client. As soon as the link layer connection is established, the DTLS handshake can start, with the client sending its initial hello . Key Management \u00b6 With PSK authentication, the DTLS client and server must share a key at the time a connection is established (the handshake). The Golden Gate library does not impose a single mechanism for that key to be shared. Any mechanism is valid, as long at the two peers agree on the key identity and the key value. Typical mechanisms for managing those authentication keys for embedded devices is to receive them as part of an initial setup/pairing protocol, where a manufacturing key may be used to secure a key delivery protocol, and/or derived from that manufacturing key. A typical mechanism for a mobile application to obtain the same authentication key is to fetch it from an online service, over a secure HTTPS connection. Bootstrap Key Mechanism \u00b6 When deploying a system where the DTLS authentication key is provisioned in the field, using a secure key distribution protocol, it is convenient to make use of CoAP through the protocol stack in order to implement that key distribution protocol. In order to keep the stack configuration the same regardless of whether a key has yet been distributed or not, it is desirable to still use DTLS during the key distribution protocol. Once the protocol completes and the two peers share a key, the DTLS protocol is restarted and a new, secure, connection is established using that key. For that purpose, a fixed, non-secure, bootstrap key may be used. This also allows easy testing of the stack for developers working on prototypes or tests which may not have the ability to obtain \"real\" shared authentication keys.","title":"Security"},{"location":"architecture/security.html#security","text":"Golden Gate supports secure end-to-end communications over its protocol stack. In the standard configuration, a protocol stack includes as the next layer after the CoAP application protocol a DTLS layer.","title":"Security"},{"location":"architecture/security.html#dtls","text":"DTLS is defined in RFC6347 . It is essentially a variant of TLS that is designed to work with UDP datagrams instead of TCP streams.","title":"DTLS"},{"location":"architecture/security.html#cipher-suites","text":"The library can be configured to support any cipher suite that is supported by the DTLS engine that is selected at build time. In the current version, the only DTLS engine support is MbedTLS, which supports an impressive range of cipher suites. In practices, when deployed on small devices, the DTLS engine is configured with a small subset of all the supported cipher suite. The standard configuration chosen is to enable the following cipher suites: TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 TLS_PSK_WITH_AES_128_CCM TLS_PSK_WITH_AES_128_GCM_SHA256 The choice of PSK here is key to keeping the DTLS handshake simple and lightweight for small devices, avoiding complex PKI certificate processing.","title":"Cipher Suites"},{"location":"architecture/security.html#client-and-server-roles","text":"In the Golden Gate network topology, the stack running in the mobile application is configured to be in the so-called Hub role, in which case its DTLS protocol layer is a DTLS server. Conversely, the embedded device to which the mobile application connects is configured to be in the so-called Node role, in which case its DTLS protocol layer is a DTLS client. As soon as the link layer connection is established, the DTLS handshake can start, with the client sending its initial hello .","title":"Client and Server Roles"},{"location":"architecture/security.html#key-management","text":"With PSK authentication, the DTLS client and server must share a key at the time a connection is established (the handshake). The Golden Gate library does not impose a single mechanism for that key to be shared. Any mechanism is valid, as long at the two peers agree on the key identity and the key value. Typical mechanisms for managing those authentication keys for embedded devices is to receive them as part of an initial setup/pairing protocol, where a manufacturing key may be used to secure a key delivery protocol, and/or derived from that manufacturing key. A typical mechanism for a mobile application to obtain the same authentication key is to fetch it from an online service, over a secure HTTPS connection.","title":"Key Management"},{"location":"architecture/security.html#bootstrap-key-mechanism","text":"When deploying a system where the DTLS authentication key is provisioned in the field, using a secure key distribution protocol, it is convenient to make use of CoAP through the protocol stack in order to implement that key distribution protocol. In order to keep the stack configuration the same regardless of whether a key has yet been distributed or not, it is desirable to still use DTLS during the key distribution protocol. Once the protocol completes and the two peers share a key, the DTLS protocol is restarted and a new, secure, connection is established using that key. For that purpose, a fixed, non-secure, bootstrap key may be used. This also allows easy testing of the stack for developers working on prototypes or tests which may not have the ability to obtain \"real\" shared authentication keys.","title":"Bootstrap Key Mechanism"},{"location":"architecture/software_architecture.html","text":"Software Architecture \u00b6 Network/Protocol Stack \u00b6 Note Not all elements in this diagram are implemented in version 1 of the framework In a network/protocol stack, is is important to have cleanly separated protocol layers. Layers are not tightly coupled, they just pass buffers to each other (see the I/O model description below) Applications and services use the \"top\" of the stack A transport, attached at the \"bottom\" of the stack connects two stacks together Many different stack configurations can be used Two connected stacks must be compatible Hub / Node \u00b6 Two connected stacks are mostly symmetric. For non-symmetric elements, we assign each stack a role . The role is also used to automatically assign a default IP address. Hub - role assumed by the mobile phone/desktop DTLS server (waits for client to handshake) Default IP address 169.254.0.2 Host may have multiple Hub stacks Node - role assumed by the tracker DTLS client (initiates handshake with server) Default IP address 169.254.0.3 Host typically has one stack Link Layer \u00b6 The most common link layer is Gattlink (streams over BLE GATT). Others include: L2CAP (a.k.a Connection Oriented Channels) UDP over Wifi/Ethernet/Loopback (for testing, bridging) Support for L2CAP channels is not complete The support for using L2CAP channels, which is a recently added feature on iOS and Android, is only experimental in the current version. GattLink \u00b6 Gattlink is a protocol that allows sending streams over a packet-oriented transport with some resilience to errors Designed with GATT in mind Single GATT write/notify is too small to send/receive a whole IP packet GATT stacks have no buffer control Symmetric - two peers, no \"client\" or \"server\" Buffer/flow control - windowing mechanism Stall detection Can run over GATT, but also other transports (L2CAP, UDP, ...) IP Networking \u00b6 IP - The base protocol IP address - each host has an IP address. 32-bit in IPv4, written as A.B.C.D \"Class\" - A, B, C, D, E. https://www.computerhope.com/jargon/i/ip.htm#classes A netmask is a 32-bit binary mask used to divide an IP address into subnets and specify the network's available hosts. Ex: 255.255.255.0 169.254.0.0/16 is used for Link Local addresses. IP packet Version, Protocol, Length, Checksum. https://en.wikipedia.org/wiki/IPv4#Header Source & Destination addresses Sockets \u00b6 A socket represents a communication channel - Unique pair of ( host / port , host / port ) UDP - Datagram-oriented communication, no guarantees Source & Destination ports (16 bits, for multiplexing) TCP - Stream-oriented communication, with reliable delivery Source & Destination ports (16 bits, for multiplexing) Windowing, retransmission Client/Server Network Interface \u00b6 A network interface sends/receives IP packets to/from a transport Ethernet, Wifi, Serial, ... Security \u00b6 All UDP traffic is protected by DTLS Same as SSL/TLS, for UDP PSK (Pre Shared Key) authentication Diffie-Hellman key agreement AES-128 CCM or AES-256 CBC for bulk ciphers See the Security page for details. I/O Model \u00b6 I/O model used to pass buffers from layer to layer, or object to object: Asynchronous \"push\" model for building data pipelines Abstract interface for a reference-counted buffer type: GG_Buffer Abstract interface for a data source: GG_DataSource Abstract interface for a data sink: GG_DataSink Designed to work well within the GG Loop Threading Model \u00b6 Single Threaded Model \u00b6 The library uses a mostly single-threaded model. Multi-threading is avoided whenever possible, mainly because: Threads are notoriously difficult and error-prone Threads use stacks Threads can easily get into race conditions Threads require locking shared data Threading Contract \u00b6 The threading contract for users of the library as well as internal modules: an object may only be used in the thread from which it was created. The thread guard is used to catch violations GG_THREAD_GUARD_BIND , GG_THREAD_GUARD_CHECK_BINDING(object) A few exceptions: Exceptions are explicitly marked as such Functions whose role is inter-thread communication Logging Memory allocation","title":"Software Architecture"},{"location":"architecture/software_architecture.html#software-architecture","text":"","title":"Software Architecture"},{"location":"architecture/software_architecture.html#networkprotocol-stack","text":"Note Not all elements in this diagram are implemented in version 1 of the framework In a network/protocol stack, is is important to have cleanly separated protocol layers. Layers are not tightly coupled, they just pass buffers to each other (see the I/O model description below) Applications and services use the \"top\" of the stack A transport, attached at the \"bottom\" of the stack connects two stacks together Many different stack configurations can be used Two connected stacks must be compatible","title":"Network/Protocol Stack"},{"location":"architecture/software_architecture.html#hub-node","text":"Two connected stacks are mostly symmetric. For non-symmetric elements, we assign each stack a role . The role is also used to automatically assign a default IP address. Hub - role assumed by the mobile phone/desktop DTLS server (waits for client to handshake) Default IP address 169.254.0.2 Host may have multiple Hub stacks Node - role assumed by the tracker DTLS client (initiates handshake with server) Default IP address 169.254.0.3 Host typically has one stack","title":"Hub / Node"},{"location":"architecture/software_architecture.html#link-layer","text":"The most common link layer is Gattlink (streams over BLE GATT). Others include: L2CAP (a.k.a Connection Oriented Channels) UDP over Wifi/Ethernet/Loopback (for testing, bridging) Support for L2CAP channels is not complete The support for using L2CAP channels, which is a recently added feature on iOS and Android, is only experimental in the current version.","title":"Link Layer"},{"location":"architecture/software_architecture.html#gattlink","text":"Gattlink is a protocol that allows sending streams over a packet-oriented transport with some resilience to errors Designed with GATT in mind Single GATT write/notify is too small to send/receive a whole IP packet GATT stacks have no buffer control Symmetric - two peers, no \"client\" or \"server\" Buffer/flow control - windowing mechanism Stall detection Can run over GATT, but also other transports (L2CAP, UDP, ...)","title":"GattLink"},{"location":"architecture/software_architecture.html#ip-networking","text":"IP - The base protocol IP address - each host has an IP address. 32-bit in IPv4, written as A.B.C.D \"Class\" - A, B, C, D, E. https://www.computerhope.com/jargon/i/ip.htm#classes A netmask is a 32-bit binary mask used to divide an IP address into subnets and specify the network's available hosts. Ex: 255.255.255.0 169.254.0.0/16 is used for Link Local addresses. IP packet Version, Protocol, Length, Checksum. https://en.wikipedia.org/wiki/IPv4#Header Source & Destination addresses","title":"IP Networking"},{"location":"architecture/software_architecture.html#sockets","text":"A socket represents a communication channel - Unique pair of ( host / port , host / port ) UDP - Datagram-oriented communication, no guarantees Source & Destination ports (16 bits, for multiplexing) TCP - Stream-oriented communication, with reliable delivery Source & Destination ports (16 bits, for multiplexing) Windowing, retransmission Client/Server","title":"Sockets"},{"location":"architecture/software_architecture.html#network-interface","text":"A network interface sends/receives IP packets to/from a transport Ethernet, Wifi, Serial, ...","title":"Network Interface"},{"location":"architecture/software_architecture.html#security","text":"All UDP traffic is protected by DTLS Same as SSL/TLS, for UDP PSK (Pre Shared Key) authentication Diffie-Hellman key agreement AES-128 CCM or AES-256 CBC for bulk ciphers See the Security page for details.","title":"Security"},{"location":"architecture/software_architecture.html#io-model","text":"I/O model used to pass buffers from layer to layer, or object to object: Asynchronous \"push\" model for building data pipelines Abstract interface for a reference-counted buffer type: GG_Buffer Abstract interface for a data source: GG_DataSource Abstract interface for a data sink: GG_DataSink Designed to work well within the GG Loop","title":"I/O Model"},{"location":"architecture/software_architecture.html#threading-model","text":"","title":"Threading Model"},{"location":"architecture/software_architecture.html#single-threaded-model","text":"The library uses a mostly single-threaded model. Multi-threading is avoided whenever possible, mainly because: Threads are notoriously difficult and error-prone Threads use stacks Threads can easily get into race conditions Threads require locking shared data","title":"Single Threaded Model"},{"location":"architecture/software_architecture.html#threading-contract","text":"The threading contract for users of the library as well as internal modules: an object may only be used in the thread from which it was created. The thread guard is used to catch violations GG_THREAD_GUARD_BIND , GG_THREAD_GUARD_CHECK_BINDING(object) A few exceptions: Exceptions are explicitly marked as such Functions whose role is inter-thread communication Logging Memory allocation","title":"Threading Contract"},{"location":"guides/index.html","text":"Developer Guides \u00b6 This section of the documentation includes several guides that will walk you through different topics, from getting started with the project and its setup, to how to use the most common APIs. Guides \u00b6 Project Layout - Description of the directories and files included in the project Build - Details about the build system for different hosts and targets Components - Guide to the software components/modules included in the project Examples - Guide to some of the example code and apps, and how to build and run them Porting - Porting guide for how to adapt the code for other operating systems Documentation - How the documentation is maintained and built","title":"Overview"},{"location":"guides/index.html#developer-guides","text":"This section of the documentation includes several guides that will walk you through different topics, from getting started with the project and its setup, to how to use the most common APIs.","title":"Developer Guides"},{"location":"guides/index.html#guides","text":"Project Layout - Description of the directories and files included in the project Build - Details about the build system for different hosts and targets Components - Guide to the software components/modules included in the project Examples - Guide to some of the example code and apps, and how to build and run them Porting - Porting guide for how to adapt the code for other operating systems Documentation - How the documentation is maintained and built","title":"Guides"},{"location":"guides/build.html","text":"","title":"Build"},{"location":"guides/coap.html","text":"","title":"CoAP"},{"location":"guides/core_concepts.html","text":"","title":"Core Concepts"},{"location":"guides/documentation.html","text":"","title":"Documentation"},{"location":"guides/events.html","text":"","title":"Events"},{"location":"guides/examples.html","text":"","title":"Examples"},{"location":"guides/gattlink.html","text":"","title":"Gattlink"},{"location":"guides/io.html","text":"","title":"I/O Model"},{"location":"guides/ip.html","text":"","title":"IP"},{"location":"guides/logging.html","text":"Logging \u00b6 The logging subsystem (xp/common/gg_logging.h) provides a simple unified set of logging macros that can be either completely compiled-out, or compiled-in with runtime level-based filters. The configuration of the logging subsystem is completely done at runtime, so you can change the logging level and log output options for each individual file (and possibly each function or code fragment if necessary). The system allows for any number of loggers to exist, and configure which loggers receive which log records, and whether log records bubble up the logger tree. Using logging macros \u00b6 To use logging in a C file, start by declaring the logger name to use for that file. Logger names consist of components separated by '.' characters. Loggers are arranged in a tree structure, where each '.' in the name is a branch in the tree. So for example, a logger named \"foo.bar.x\" is a child of \"foo.bar\", which is a child of \"foo\". At the top of the tree is always the root logger. The name of the root logger is the empty string. To declare the logger name for a file, use the macro: GG_SET_LOCAL_LOGGER(\"foo.bar.x\") Then, in the code, a log record can be emitted by using the macros: GG_LOG_XXX(...) where XXX is the logging level ( FATAL , SEVERE , WARNING , INFO , FINE , FINER , FINEST ) and the argument is a printf-compatible (format, params...) list. Example: GG_LOG_FINEST(\"Hello %s %s\", \"Golden\", \"Gate\"); Using custom loggers \u00b6 If you need to use multiple loggers in a single C file, or pass the logging level dynamically, advanced macros are available. You can define a logger using GG_DEFINE_LOGGER(<logger-symbol>, <logger-name>) Example: GG_DEFINE_LOGGER(FooLogger, \"gg.test.foo\") Then you can emit a log record to that specific logger by using the GG_LOG_L_XXX(...) macros. Example: GG_LOG_INFO_L(FooLogger, \"Hello from FooLogger\"); Configuring the loggers \u00b6 Configuration of the loggers is done using a simple syntax. The configuration may come from different sources depending on the system on which the code is running. The most common way to configure the loggers is by passing the log config in an environment variable. Optionally, on systems that have a filesystem, a log configuration file can be used. When using an environment variable, the GG_LOG_CONFIG variable may be set to specify the log configuration source. The simplest source is an in-line configuration, which is signaled by using the form: plist:xxx where xxx is a sequence of one or more log config entries, separated by ';' characters. Example: export GG_LOG_CONFIG=plist:.level=ALL If more than one log config source is needed, they are specified in a list, separated by '|' characters. Example: Example: export GG_LOG_CONFIG=plist:.level=ALL|file:my_log_config.properties plist source \u00b6 A plist: log config is a sequence of one or more configuration properties, separated with ';' characters. Log configuration properties \u00b6 A log configuration property entry is either a logger configuration property or a log handler configuration property. Logger configuration properties \u00b6 A logger configuration property has the form: <logger>.level , <logger>.handlers or <logger>.forward . <logger>.level : a symbolic or numeric log level for the logger. The logger will only handle log events with a level equal or higher to this level. The level can be set to OFF to ignore all log events, or to ALL to handle all log events. When no level property is specified for a logger, the logger inherits its parent\u2019s log level. <logger>.handlers : a comma-separated list of handlers. The name of the builtin handlers are: NullHandler , ConsoleHandler , FileHandler . Some platforms may have more types of handlers available. <logger>.forward : a boolean value. When set to false, the logger does not forward the log event records to its parent. When set to true, the logger forwards log event records to its parent. If this property is not specified, the default behavior of loggers is to forward log even records to their parent. Boolean values are true or false. False can be written as false , off , no , or 0 . True can be written as true , on , yes , or 1 . Handler configuration properties \u00b6 When a logger <logger> is configured with a list of handlers, each handler <handler> can be configured by setting properties with the prefix <logger>.<handler> . NOTE: the root logger has a ConsoleHandler by default, so this does not need to be specified in the log configuration. Console Handler \u00b6 <logger>.ConsoleHandler.colors : a Boolean value that specifies whether to use ansi terminal color escape sequences. <logger>.ConsoleHandler.filter : a filter mask for the log records. Use a OR combination of: - 1: do not include the name of the source file in the log output - 2: do not include the timestamp in the log output - 4: do not include the function name in the log output - 8: do not include the log level in the log output File Handler \u00b6 <logger>.FileHandler.filename : Name of the file to write to. If this property is not specified, FileHandler handlers write to a file with the name <logger>.log Examples \u00b6 export GG_LOG_CONFIG=\"plist:.level=INFO;.ConsoleHandler.filter=3;foo.bar.y.level=FINE;foo.bar.y.handlers=ConsoleHandler;foo.forward=false\" This sets the root logger level to INFO , the root logger's ConsoleHandler filter to 3, and foo.bar.y logger level to FINE , uses the ConsoleHandler to handle log records emitted by the foo.bar.y logger, and sets the foo logger to not forward to its parent (which by extension means that any logger below foo , such as the foo.bar.y logger, will not bubble up all the way to the root).","title":"Logging"},{"location":"guides/logging.html#logging","text":"The logging subsystem (xp/common/gg_logging.h) provides a simple unified set of logging macros that can be either completely compiled-out, or compiled-in with runtime level-based filters. The configuration of the logging subsystem is completely done at runtime, so you can change the logging level and log output options for each individual file (and possibly each function or code fragment if necessary). The system allows for any number of loggers to exist, and configure which loggers receive which log records, and whether log records bubble up the logger tree.","title":"Logging"},{"location":"guides/logging.html#using-logging-macros","text":"To use logging in a C file, start by declaring the logger name to use for that file. Logger names consist of components separated by '.' characters. Loggers are arranged in a tree structure, where each '.' in the name is a branch in the tree. So for example, a logger named \"foo.bar.x\" is a child of \"foo.bar\", which is a child of \"foo\". At the top of the tree is always the root logger. The name of the root logger is the empty string. To declare the logger name for a file, use the macro: GG_SET_LOCAL_LOGGER(\"foo.bar.x\") Then, in the code, a log record can be emitted by using the macros: GG_LOG_XXX(...) where XXX is the logging level ( FATAL , SEVERE , WARNING , INFO , FINE , FINER , FINEST ) and the argument is a printf-compatible (format, params...) list. Example: GG_LOG_FINEST(\"Hello %s %s\", \"Golden\", \"Gate\");","title":"Using logging macros"},{"location":"guides/logging.html#using-custom-loggers","text":"If you need to use multiple loggers in a single C file, or pass the logging level dynamically, advanced macros are available. You can define a logger using GG_DEFINE_LOGGER(<logger-symbol>, <logger-name>) Example: GG_DEFINE_LOGGER(FooLogger, \"gg.test.foo\") Then you can emit a log record to that specific logger by using the GG_LOG_L_XXX(...) macros. Example: GG_LOG_INFO_L(FooLogger, \"Hello from FooLogger\");","title":"Using custom loggers"},{"location":"guides/logging.html#configuring-the-loggers","text":"Configuration of the loggers is done using a simple syntax. The configuration may come from different sources depending on the system on which the code is running. The most common way to configure the loggers is by passing the log config in an environment variable. Optionally, on systems that have a filesystem, a log configuration file can be used. When using an environment variable, the GG_LOG_CONFIG variable may be set to specify the log configuration source. The simplest source is an in-line configuration, which is signaled by using the form: plist:xxx where xxx is a sequence of one or more log config entries, separated by ';' characters. Example: export GG_LOG_CONFIG=plist:.level=ALL If more than one log config source is needed, they are specified in a list, separated by '|' characters. Example: Example: export GG_LOG_CONFIG=plist:.level=ALL|file:my_log_config.properties","title":"Configuring the loggers"},{"location":"guides/logging.html#plist-source","text":"A plist: log config is a sequence of one or more configuration properties, separated with ';' characters.","title":"plist source"},{"location":"guides/logging.html#log-configuration-properties","text":"A log configuration property entry is either a logger configuration property or a log handler configuration property.","title":"Log configuration properties"},{"location":"guides/logging.html#logger-configuration-properties","text":"A logger configuration property has the form: <logger>.level , <logger>.handlers or <logger>.forward . <logger>.level : a symbolic or numeric log level for the logger. The logger will only handle log events with a level equal or higher to this level. The level can be set to OFF to ignore all log events, or to ALL to handle all log events. When no level property is specified for a logger, the logger inherits its parent\u2019s log level. <logger>.handlers : a comma-separated list of handlers. The name of the builtin handlers are: NullHandler , ConsoleHandler , FileHandler . Some platforms may have more types of handlers available. <logger>.forward : a boolean value. When set to false, the logger does not forward the log event records to its parent. When set to true, the logger forwards log event records to its parent. If this property is not specified, the default behavior of loggers is to forward log even records to their parent. Boolean values are true or false. False can be written as false , off , no , or 0 . True can be written as true , on , yes , or 1 .","title":"Logger configuration properties"},{"location":"guides/logging.html#handler-configuration-properties","text":"When a logger <logger> is configured with a list of handlers, each handler <handler> can be configured by setting properties with the prefix <logger>.<handler> . NOTE: the root logger has a ConsoleHandler by default, so this does not need to be specified in the log configuration.","title":"Handler configuration properties"},{"location":"guides/logging.html#console-handler","text":"<logger>.ConsoleHandler.colors : a Boolean value that specifies whether to use ansi terminal color escape sequences. <logger>.ConsoleHandler.filter : a filter mask for the log records. Use a OR combination of: - 1: do not include the name of the source file in the log output - 2: do not include the timestamp in the log output - 4: do not include the function name in the log output - 8: do not include the log level in the log output","title":"Console Handler"},{"location":"guides/logging.html#file-handler","text":"<logger>.FileHandler.filename : Name of the file to write to. If this property is not specified, FileHandler handlers write to a file with the name <logger>.log","title":"File Handler"},{"location":"guides/logging.html#examples","text":"export GG_LOG_CONFIG=\"plist:.level=INFO;.ConsoleHandler.filter=3;foo.bar.y.level=FINE;foo.bar.y.handlers=ConsoleHandler;foo.forward=false\" This sets the root logger level to INFO , the root logger's ConsoleHandler filter to 3, and foo.bar.y logger level to FINE , uses the ConsoleHandler to handle log records emitted by the foo.bar.y logger, and sets the foo logger to not forward to its parent (which by extension means that any logger below foo , such as the foo.bar.y logger, will not bubble up all the way to the root).","title":"Examples"},{"location":"guides/loop.html","text":"","title":"Loop"},{"location":"guides/object_oriented_c.html","text":"Object-Oriented C \u00b6","title":"Object-Oriented C"},{"location":"guides/object_oriented_c.html#object-oriented-c","text":"","title":"Object-Oriented C"},{"location":"guides/portable_runtime.html","text":"","title":"Portable Runtime"},{"location":"guides/porting.html","text":"","title":"Porting"},{"location":"guides/project_layout.html","text":"","title":"Project Layout"},{"location":"guides/sockets.html","text":"","title":"Sockets"},{"location":"guides/stack.html","text":"","title":"Stack"},{"location":"guides/tls.html","text":"","title":"TLS"},{"location":"guides/utils.html","text":"","title":"Utils"},{"location":"guides/code-styles/c.html","text":"C Coding Conventions \u00b6 For code that is single-platform (such as iOS, Android, Bison, or other platform-specific code modules), the coding conventions for that platform are used. For XP (Cross Platform) code, which is C code designed to be both independent of platform-specific code repositories and platform-specific APIs, the C coding conventions are specific to Golden Gate. General C Conventions \u00b6 For things that work the same in C and C++, the coding style should follow the Google C++ Style Guide . However, since the Golden Gate XP code is in C, not C++, there are few other elements that come into play. Namespacing \u00b6 Since C doesn't offer builtin support for namespacing, we will use a poor-man's namespacing technique, by using prefixed for all names that require a namespace (mostly to avoid name collisions). The common prefix for preprocessor symbols, function names and other visible names is GG_ . (Why be so strict about namespace prefixing? Try looking for the constant MAX_MSG_SIZE in a large code base with multiple independent modules and submodules...) Examples: #define GG_LINK_MTU 251 void GG_ComputeCrc ( const uint8_t * data , unsigned int data_size ); typedef enum { GG_PACKET_TYPE_FOO , GG_PACKET_TYPE_BAR } GG_PacketType ; Object-Oriented C \u00b6 Simple Classes \u00b6 For code modules that implement class-like types, with encapsulated data and methods, the recommended naming convention for structs and functions is like this: GG_<class_name>_<method_name> where ` `` should read like an action performed on the type. Examples typedef struct GG_Socket GG_Socket ; // opaque type for GG_Socket class GG_Result GG_Socket_SendDatagram ( GG_Socket * self , const GG_Datagram * datagram ); Virtual Methods \u00b6 For classes that are designed to have a shared abstract class and multiple concrete implementations, the recommendation is to define an abstract object base which consists of a named structure whose first field is a pointer to a function table. The pattern looks like this for an interface named GG_Foobar: typedef struct GG_FoobarInterface GG_FoobarInterface ; typedef struct { const GG_FoobarInterface * iface ; } GG_Foobar ; struct GG_FoobarInterface { GG_Result SomeMethod ( GG_Foobar * self , uint8_t param ); }; To simplify the boilerplate, use the macro GG_DECLARE_INTERFACE, like this: (which is equivalent to the above) GG_DECLARE_INTERFACE ( GG_Foobar ) { GG_Result SomeMethod ( GG_Foobar * self , uint8_t param ); }; // Typical implementation of the method Polymorphism \u00b6 For classes that implement multiple interfaces, the pattern is to embed multiple abstract base class structures in the implemented class structure, and use offsetof() to get pointers back to the instance data. For example, a class that implements interfaces GG_Foo and GG_Bar would be declared like this: typedef struct { GG_IMPLEMENTS ( GG_Foo ); GG_IMPLEMENTS ( GG_Bar ); unsigned int my_member_variable ; } MyFoobarImplementation ; supposing that the GG_Foo and GG_Bar interfaces are declared like this: GG_DECLARE_INTERFACE ( GG_Foo ) { GG_Result DoSomething1 ( GG_Foo * self , uint8_t param1 ); GG_Result DoSomething2 ( GG_Foo * self , const char * param2 ); }; GG_DECLARE_INTERFACE ( GG_Bar ) { GG_Result WorkOnSomething ( GG_Foo * self , const char * param ); }; Then in the implementation for MyFooBarImplementation may look like: static GG_Result MyFoobarImplementation_DoSomething1 ( GG_Foo * _self , uint8_t param1 ) { MyFoobarImplementation * self = GG_SELF ( MyFoobarImplementation , GG_Foo ); // ... } static GG_Result MyFoobarImplementation_DoSomething2 ( GG_Foo * _self , const char * param2 ) { MyFoobarImplementation * self = GG_SELF ( MyFoobarImplementation , GG_Bar ); // ... } static GG_Result MyFoobarImplementation_WorkOnSomething ( GG_Bar * _self , const char * name ) { MyFoobarImplementation * self = GG_SELF ( MyFoobarImplementation , GG_Bar ); // ... } Setting up the function table pointers can also be done easily using the GG_SET_INTERFACE macro: GG_IMPLEMENT_INTERFACE ( GG_Foo , MyFoobarImplementation ) { MyFoobarImplementation_DoSomething1 , MyFoobarImplementation_DoSomething2 }; GG_IMPLEMENT_INTERFACE ( GG_Bar , MyFoobarImplementation ) { MyFoobarImplementation_WorkOnSomething }; static void MyFoobarImplementation_Init ( MyFoobarImplementation * self ) { // init the class members ... // // setup the function tables GG_SET_INTERFACE ( self , MyFoobarImplementation , GG_Foo ); GG_SET_INTERFACE ( self , MyFoobarImplementation , GG_Bar ); } File Names \u00b6 While not strictly necessary, it is recommended that file names be prefixed as well. Some build systems often use simple basenames and search paths to locate source and header files, so \"naked\" file names can quickly become a problem in diverse code base where we don't control all the files. For example, naming one of our files udp.c would be asking for trouble. That file should instead be named gg_udp.c , thus preventing possible collisions. The same goes for include files (even though include files can sometimes be prefixed implicitly by putting them in a uniquely named directory, and using that directory name explicitly when including). So gg_udp.h rather than just udp.h","title":"C"},{"location":"guides/code-styles/c.html#c-coding-conventions","text":"For code that is single-platform (such as iOS, Android, Bison, or other platform-specific code modules), the coding conventions for that platform are used. For XP (Cross Platform) code, which is C code designed to be both independent of platform-specific code repositories and platform-specific APIs, the C coding conventions are specific to Golden Gate.","title":"C Coding Conventions"},{"location":"guides/code-styles/c.html#general-c-conventions","text":"For things that work the same in C and C++, the coding style should follow the Google C++ Style Guide . However, since the Golden Gate XP code is in C, not C++, there are few other elements that come into play.","title":"General C Conventions"},{"location":"guides/code-styles/c.html#namespacing","text":"Since C doesn't offer builtin support for namespacing, we will use a poor-man's namespacing technique, by using prefixed for all names that require a namespace (mostly to avoid name collisions). The common prefix for preprocessor symbols, function names and other visible names is GG_ . (Why be so strict about namespace prefixing? Try looking for the constant MAX_MSG_SIZE in a large code base with multiple independent modules and submodules...) Examples: #define GG_LINK_MTU 251 void GG_ComputeCrc ( const uint8_t * data , unsigned int data_size ); typedef enum { GG_PACKET_TYPE_FOO , GG_PACKET_TYPE_BAR } GG_PacketType ;","title":"Namespacing"},{"location":"guides/code-styles/c.html#object-oriented-c","text":"","title":"Object-Oriented C"},{"location":"guides/code-styles/c.html#simple-classes","text":"For code modules that implement class-like types, with encapsulated data and methods, the recommended naming convention for structs and functions is like this: GG_<class_name>_<method_name> where ` `` should read like an action performed on the type. Examples typedef struct GG_Socket GG_Socket ; // opaque type for GG_Socket class GG_Result GG_Socket_SendDatagram ( GG_Socket * self , const GG_Datagram * datagram );","title":"Simple Classes"},{"location":"guides/code-styles/c.html#virtual-methods","text":"For classes that are designed to have a shared abstract class and multiple concrete implementations, the recommendation is to define an abstract object base which consists of a named structure whose first field is a pointer to a function table. The pattern looks like this for an interface named GG_Foobar: typedef struct GG_FoobarInterface GG_FoobarInterface ; typedef struct { const GG_FoobarInterface * iface ; } GG_Foobar ; struct GG_FoobarInterface { GG_Result SomeMethod ( GG_Foobar * self , uint8_t param ); }; To simplify the boilerplate, use the macro GG_DECLARE_INTERFACE, like this: (which is equivalent to the above) GG_DECLARE_INTERFACE ( GG_Foobar ) { GG_Result SomeMethod ( GG_Foobar * self , uint8_t param ); }; // Typical implementation of the method","title":"Virtual Methods"},{"location":"guides/code-styles/c.html#polymorphism","text":"For classes that implement multiple interfaces, the pattern is to embed multiple abstract base class structures in the implemented class structure, and use offsetof() to get pointers back to the instance data. For example, a class that implements interfaces GG_Foo and GG_Bar would be declared like this: typedef struct { GG_IMPLEMENTS ( GG_Foo ); GG_IMPLEMENTS ( GG_Bar ); unsigned int my_member_variable ; } MyFoobarImplementation ; supposing that the GG_Foo and GG_Bar interfaces are declared like this: GG_DECLARE_INTERFACE ( GG_Foo ) { GG_Result DoSomething1 ( GG_Foo * self , uint8_t param1 ); GG_Result DoSomething2 ( GG_Foo * self , const char * param2 ); }; GG_DECLARE_INTERFACE ( GG_Bar ) { GG_Result WorkOnSomething ( GG_Foo * self , const char * param ); }; Then in the implementation for MyFooBarImplementation may look like: static GG_Result MyFoobarImplementation_DoSomething1 ( GG_Foo * _self , uint8_t param1 ) { MyFoobarImplementation * self = GG_SELF ( MyFoobarImplementation , GG_Foo ); // ... } static GG_Result MyFoobarImplementation_DoSomething2 ( GG_Foo * _self , const char * param2 ) { MyFoobarImplementation * self = GG_SELF ( MyFoobarImplementation , GG_Bar ); // ... } static GG_Result MyFoobarImplementation_WorkOnSomething ( GG_Bar * _self , const char * name ) { MyFoobarImplementation * self = GG_SELF ( MyFoobarImplementation , GG_Bar ); // ... } Setting up the function table pointers can also be done easily using the GG_SET_INTERFACE macro: GG_IMPLEMENT_INTERFACE ( GG_Foo , MyFoobarImplementation ) { MyFoobarImplementation_DoSomething1 , MyFoobarImplementation_DoSomething2 }; GG_IMPLEMENT_INTERFACE ( GG_Bar , MyFoobarImplementation ) { MyFoobarImplementation_WorkOnSomething }; static void MyFoobarImplementation_Init ( MyFoobarImplementation * self ) { // init the class members ... // // setup the function tables GG_SET_INTERFACE ( self , MyFoobarImplementation , GG_Foo ); GG_SET_INTERFACE ( self , MyFoobarImplementation , GG_Bar ); }","title":"Polymorphism"},{"location":"guides/code-styles/c.html#file-names","text":"While not strictly necessary, it is recommended that file names be prefixed as well. Some build systems often use simple basenames and search paths to locate source and header files, so \"naked\" file names can quickly become a problem in diverse code base where we don't control all the files. For example, naming one of our files udp.c would be asking for trouble. That file should instead be named gg_udp.c , thus preventing possible collisions. The same goes for include files (even though include files can sometimes be prefixed implicitly by putting them in a uniquely named directory, and using that directory name explicitly when including). So gg_udp.h rather than just udp.h","title":"File Names"},{"location":"guides/code-styles/kotlin.html","text":"","title":"Kotlin"},{"location":"guides/code-styles/swift.html","text":"","title":"Swift"},{"location":"platforms/index.html","text":"Supported Platforms \u00b6","title":"Overview"},{"location":"platforms/index.html#supported-platforms","text":"","title":"Supported Platforms"},{"location":"platforms/android.html","text":"Android Platform \u00b6 Setup \u00b6 Java On Linux \u00b6 If you're on a Linux host, make sure you have jre 8. For example, on ubuntu: $ sudo apt install openjdk-8-jdk Tip If you have multiple jdk's installed, select jre 8 with: # print available versions $ update-java-alternatives --list # select openjdk-8, eg: $ sudo update-java-alternatives --set /usr/lib/jvm/java-1.8.0-openjdk-amd64 Install Android Studio \u00b6 Download Android Studio or at least the Android command line tools from Google On Linux \u00b6 After installing (to eg ~/android-studio ), launch studio and follow the wizard. It will prompt for a path to install the SDK component to; this can be anywhere, eg ~/android-sdk . Install The Android SDK Components \u00b6 From Android studio, open the SDK manager (the icon looks like a down arrow and the head of the Android logo) and install Android 8.1, Android 8.0, Android 5.0, Android 7.1, NDK, Android SDK Tools, Android SDK Platform-Tools, Android Support Library, LLDB, CMake, Android SDK Build-Tools, and everything under the Support Library header. You can skip the emulator images to save some disk space. Alternatively, on Linux, you can install the SDK components from the command line: $ sdk/tools/bin/sdkmanager \\ 'platforms;android-26' \\ 'platforms;android-21' \\ 'platforms;android-25' \\ 'platforms;android-26' \\ 'platforms;android-27' \\ 'platforms;android-28' \\ 'platforms;android-29' \\ 'ndk-bundle' \\ 'cmake;3.6.4111459' \\ 'lldb;3.0' \\ 'build-tools;27.0.3' \\ 'platform-tools' \\ 'extras;m2repository;com;android;support;constraint;constraint-layout;1.0.2' \\ 'extras;m2repository;com;android;support;constraint;constraint-layout-solver;1.0.2' \\ 'extras;android;m2repository' \\ 'extras;google;m2repository' Setup You Environment \u00b6 Set the ANDROID_HOME environment variable to point to the SDK directory (eg export ANDROID_HOME=~/android-sdk in your ~/.bashrc ) Build The Core Library And Host App \u00b6 To build the core library, run $ inv android.library.build To build the Host App, open Android Studio and import the Golden Gate project, which lives in platform/android/goldengate Now you can run and/or debug the app from Android studio. Alternatively, you can build the Host App from the command line: $ inv android.host.build which produces an APK at platform/android/goldengate/app/build/outputs/apk/debug/app-debug.apk which you can install with adb install app-debug.apk If you wish to build the library and Host App with one command, run: $ inv android.build Run The Host App \u00b6 See the Android Host App documentation.","title":"Android"},{"location":"platforms/android.html#android-platform","text":"","title":"Android Platform"},{"location":"platforms/android.html#setup","text":"","title":"Setup"},{"location":"platforms/android.html#java-on-linux","text":"If you're on a Linux host, make sure you have jre 8. For example, on ubuntu: $ sudo apt install openjdk-8-jdk Tip If you have multiple jdk's installed, select jre 8 with: # print available versions $ update-java-alternatives --list # select openjdk-8, eg: $ sudo update-java-alternatives --set /usr/lib/jvm/java-1.8.0-openjdk-amd64","title":"Java On Linux"},{"location":"platforms/android.html#install-android-studio","text":"Download Android Studio or at least the Android command line tools from Google","title":"Install Android Studio"},{"location":"platforms/android.html#on-linux","text":"After installing (to eg ~/android-studio ), launch studio and follow the wizard. It will prompt for a path to install the SDK component to; this can be anywhere, eg ~/android-sdk .","title":"On Linux"},{"location":"platforms/android.html#install-the-android-sdk-components","text":"From Android studio, open the SDK manager (the icon looks like a down arrow and the head of the Android logo) and install Android 8.1, Android 8.0, Android 5.0, Android 7.1, NDK, Android SDK Tools, Android SDK Platform-Tools, Android Support Library, LLDB, CMake, Android SDK Build-Tools, and everything under the Support Library header. You can skip the emulator images to save some disk space. Alternatively, on Linux, you can install the SDK components from the command line: $ sdk/tools/bin/sdkmanager \\ 'platforms;android-26' \\ 'platforms;android-21' \\ 'platforms;android-25' \\ 'platforms;android-26' \\ 'platforms;android-27' \\ 'platforms;android-28' \\ 'platforms;android-29' \\ 'ndk-bundle' \\ 'cmake;3.6.4111459' \\ 'lldb;3.0' \\ 'build-tools;27.0.3' \\ 'platform-tools' \\ 'extras;m2repository;com;android;support;constraint;constraint-layout;1.0.2' \\ 'extras;m2repository;com;android;support;constraint;constraint-layout-solver;1.0.2' \\ 'extras;android;m2repository' \\ 'extras;google;m2repository'","title":"Install The Android SDK Components"},{"location":"platforms/android.html#setup-you-environment","text":"Set the ANDROID_HOME environment variable to point to the SDK directory (eg export ANDROID_HOME=~/android-sdk in your ~/.bashrc )","title":"Setup You Environment"},{"location":"platforms/android.html#build-the-core-library-and-host-app","text":"To build the core library, run $ inv android.library.build To build the Host App, open Android Studio and import the Golden Gate project, which lives in platform/android/goldengate Now you can run and/or debug the app from Android studio. Alternatively, you can build the Host App from the command line: $ inv android.host.build which produces an APK at platform/android/goldengate/app/build/outputs/apk/debug/app-debug.apk which you can install with adb install app-debug.apk If you wish to build the library and Host App with one command, run: $ inv android.build","title":"Build The Core Library And Host App"},{"location":"platforms/android.html#run-the-host-app","text":"See the Android Host App documentation.","title":"Run The Host App"},{"location":"platforms/embedded.html","text":"Embedded Platforms \u00b6","title":"Generic"},{"location":"platforms/embedded.html#embedded-platforms","text":"","title":"Embedded Platforms"},{"location":"platforms/esp32.html","text":"Espressif ESP32 Platform \u00b6","title":"ESP32"},{"location":"platforms/esp32.html#espressif-esp32-platform","text":"","title":"Espressif ESP32 Platform"},{"location":"platforms/ios.html","text":"iOS Platform \u00b6 Setup \u00b6 Before you can open the XCode workspace, you will need to install(and build) the project's dependencies. The Carthage package and dependency manager is used for that. This bootstrap step is only needed the first time you setup the project, or after Start by running $ inv apple.bootstrap Be patient... When you run inv apple.bootstrap the first time, it may take a while, as it will likely pull in all the dependencies and build them from source. After that bootstrap step has finished, the workspace can be opened. $ open platform/apple/GoldenGate.xcworkspace Build The Host App \u00b6 You can now build the GoldenGateHost-iOS app: Pick GoldenGateHost-iOS and then select your connected device You will need an Apple developer account in order to deploy the host app to a real phone. Alternatively the simulator can be used, except if you need Bluetooth which Apple stopped supporting a while ago. Run The Host App \u00b6 In XCode, click Run (the \"Play\" icon). See the iOS Host App documentation for details.","title":"iOS"},{"location":"platforms/ios.html#ios-platform","text":"","title":"iOS Platform"},{"location":"platforms/ios.html#setup","text":"Before you can open the XCode workspace, you will need to install(and build) the project's dependencies. The Carthage package and dependency manager is used for that. This bootstrap step is only needed the first time you setup the project, or after Start by running $ inv apple.bootstrap Be patient... When you run inv apple.bootstrap the first time, it may take a while, as it will likely pull in all the dependencies and build them from source. After that bootstrap step has finished, the workspace can be opened. $ open platform/apple/GoldenGate.xcworkspace","title":"Setup"},{"location":"platforms/ios.html#build-the-host-app","text":"You can now build the GoldenGateHost-iOS app: Pick GoldenGateHost-iOS and then select your connected device You will need an Apple developer account in order to deploy the host app to a real phone. Alternatively the simulator can be used, except if you need Bluetooth which Apple stopped supporting a while ago.","title":"Build The Host App"},{"location":"platforms/ios.html#run-the-host-app","text":"In XCode, click Run (the \"Play\" icon). See the iOS Host App documentation for details.","title":"Run The Host App"},{"location":"platforms/linux.html","text":"Linux Platform \u00b6","title":"Linux"},{"location":"platforms/linux.html#linux-platform","text":"","title":"Linux Platform"},{"location":"platforms/macos.html","text":"","title":"macOS"},{"location":"platforms/mynewt.html","text":"MyNewt Port \u00b6 Two apps are included, one where the board runs as a Bluetooth central, and one where it runs as a peripheral. They are both built the same way. To build, flash and run the apps, you need to have the newt tool as well as the Segger JLink tools installed. On a mac, the newt tool should have been installed for you when you ran the brew bundle setup command. If you are using the docker image, it is also installed. If you want to install it separately, visit the MyNewt installation instructions. You will need version 1.7 or later of the newt tool. The instructions here assume that you are using the Nordic nRF52840 DK Development Kit . You should be able to run on different boards (with Bluetooth) with minor adjustments. Prepare You Board \u00b6 Before you can flash and run the gg-central or gg-peripheral app on your board, you will need to perform a one-time setup of your board, where the flash will be initialized and the bootloader installed. Ensure your board is plugged in to a USB port on your system and turned on. Run $ pylon.provision This will setup the flash as well as build and flash the bootloader. Newt 1.7 bug A bug in version 1.7 of newt exists, where it will print an error message after installing the bootloader dependency. You can safely ignore that error message. Build The Apps \u00b6 Build the gg-peripheral app: $ pylon.apps.gg-peripheral.build Build the gg-central app: $ pylon.apps.gg-central.build MyNewt dependencies If you have not built any of the Pylon projects earlier, the MyNewt dependencies should be installed for you automatically. If that is not the case, you can install them manually with pylon.apps.gg-central.install-project and pylon.apps.gg-peripheral.install-project . Run The Apps \u00b6 See the MyNewt Apps documentation for details.","title":"MyNewt"},{"location":"platforms/mynewt.html#mynewt-port","text":"Two apps are included, one where the board runs as a Bluetooth central, and one where it runs as a peripheral. They are both built the same way. To build, flash and run the apps, you need to have the newt tool as well as the Segger JLink tools installed. On a mac, the newt tool should have been installed for you when you ran the brew bundle setup command. If you are using the docker image, it is also installed. If you want to install it separately, visit the MyNewt installation instructions. You will need version 1.7 or later of the newt tool. The instructions here assume that you are using the Nordic nRF52840 DK Development Kit . You should be able to run on different boards (with Bluetooth) with minor adjustments.","title":"MyNewt Port"},{"location":"platforms/mynewt.html#prepare-you-board","text":"Before you can flash and run the gg-central or gg-peripheral app on your board, you will need to perform a one-time setup of your board, where the flash will be initialized and the bootloader installed. Ensure your board is plugged in to a USB port on your system and turned on. Run $ pylon.provision This will setup the flash as well as build and flash the bootloader. Newt 1.7 bug A bug in version 1.7 of newt exists, where it will print an error message after installing the bootloader dependency. You can safely ignore that error message.","title":"Prepare You Board"},{"location":"platforms/mynewt.html#build-the-apps","text":"Build the gg-peripheral app: $ pylon.apps.gg-peripheral.build Build the gg-central app: $ pylon.apps.gg-central.build MyNewt dependencies If you have not built any of the Pylon projects earlier, the MyNewt dependencies should be installed for you automatically. If that is not the case, you can install them manually with pylon.apps.gg-central.install-project and pylon.apps.gg-peripheral.install-project .","title":"Build The Apps"},{"location":"platforms/mynewt.html#run-the-apps","text":"See the MyNewt Apps documentation for details.","title":"Run The Apps"},{"location":"platforms/nuttx.html","text":"","title":"NuttX"},{"location":"platforms/ports.html","text":"Operating System Ports \u00b6 The project includes existing ports to a number of base operating systems: Linux - a port of the core libraries and tools to Linux. Android - a combination of the core libraries written in C and Kotlin bindings, with a JNI bridge between the two iOS - a combination of the core libraries written in C and Swift bindings Windows - which can run on Windows 10 (the bluetooth bindings are not yet included in the project) MyNewt - a port of the core libraries and bluetooth bindings to the Apache MyNewt RTOS FreeRTOS - a port of the core libraries to the FreeRTOS RTOS NuttX - a port to the NuttX RTOS ThreadX - a port of the core libraries to the ThreadX RTOS","title":"OS/RTOS Ports"},{"location":"platforms/ports.html#operating-system-ports","text":"The project includes existing ports to a number of base operating systems: Linux - a port of the core libraries and tools to Linux. Android - a combination of the core libraries written in C and Kotlin bindings, with a JNI bridge between the two iOS - a combination of the core libraries written in C and Swift bindings Windows - which can run on Windows 10 (the bluetooth bindings are not yet included in the project) MyNewt - a port of the core libraries and bluetooth bindings to the Apache MyNewt RTOS FreeRTOS - a port of the core libraries to the FreeRTOS RTOS NuttX - a port to the NuttX RTOS ThreadX - a port of the core libraries to the ThreadX RTOS","title":"Operating System Ports"},{"location":"platforms/windows.html","text":"Windows Platform \u00b6","title":"Windows"},{"location":"platforms/windows.html#windows-platform","text":"","title":"Windows Platform"},{"location":"platforms/zephyr.html","text":"Zephyr Platform \u00b6","title":"Zephyr"},{"location":"platforms/zephyr.html#zephyr-platform","text":"","title":"Zephyr Platform"},{"location":"tools/index.html","text":"Tools \u00b6 A few command-line tools are included in the project. They can be used as tools to perform specific tasks, but also as examples of how an application may use the Golden Gate APIs. The tools include: The Stack Tool - swiss-army-knife tool that can be used to run different configurations of a Golden Gate stack, in a process, connected to both another stack on another device through a link/transport, and a client or server app that can communicate through the stack. The CoAP Client - simple command-line CoAP client built using the Golden Gate CoAP API. The CoAP Server - example command-line CoAP server built using the Golden Gate CoAP API.","title":"Tools"},{"location":"tools/index.html#tools","text":"A few command-line tools are included in the project. They can be used as tools to perform specific tasks, but also as examples of how an application may use the Golden Gate APIs. The tools include: The Stack Tool - swiss-army-knife tool that can be used to run different configurations of a Golden Gate stack, in a process, connected to both another stack on another device through a link/transport, and a client or server app that can communicate through the stack. The CoAP Client - simple command-line CoAP client built using the Golden Gate CoAP API. The CoAP Server - example command-line CoAP server built using the Golden Gate CoAP API.","title":"Tools"},{"location":"tools/coap_client.html","text":"CoAP Client Command Line Tool \u00b6 The GG coap client tool is a simple command-line application that can be used to send CoAP requests to a CoAP server and print the response that it receives. Usage \u00b6 gg-coap-client get|put|post|delete [options] <uri> were URI must be of the form: coap://<ipv4-addr>[:port]/<path>[?<query>] options: -q : be quiet (don't print out log/trace information) -p <payload-filename> : name of the file containing the payload to put/post -o <option>=<value> (supported options: 'Content-Format=<uint>', Block1=<uint>, Block2=<uint>, Size1=<uint>, Size2=<uint>, Start-Offset=<uint>, If-Match=<opaque-hex>) -b <preferred-block-size> (16, 32, 64, 128, 256, 512 or 1024 for block-wise) transfers, or 0 to force a non-blockwise transfer -s <filename> : save the response payload to <filename> -t <ack-timeout> : response ACK timeout, in milliseconds -r <max-resend-count>: maximum number of resends upon request timeouts Examples \u00b6 GET Request \u00b6 Send a GET request to a server, running on the local host, for its /helloworld resource $ gg-coap-client get coap://127.0.0.1/helloworld POST Request \u00b6 Send a POST request to a server, running on the local host, to its /inbox resource, using the contents of the file payload.bin as the request payload. $ gg-coap-client post -p payload.bin coap://127.0.0.1/inbox","title":"CoAP Client"},{"location":"tools/coap_client.html#coap-client-command-line-tool","text":"The GG coap client tool is a simple command-line application that can be used to send CoAP requests to a CoAP server and print the response that it receives.","title":"CoAP Client Command Line Tool"},{"location":"tools/coap_client.html#usage","text":"gg-coap-client get|put|post|delete [options] <uri> were URI must be of the form: coap://<ipv4-addr>[:port]/<path>[?<query>] options: -q : be quiet (don't print out log/trace information) -p <payload-filename> : name of the file containing the payload to put/post -o <option>=<value> (supported options: 'Content-Format=<uint>', Block1=<uint>, Block2=<uint>, Size1=<uint>, Size2=<uint>, Start-Offset=<uint>, If-Match=<opaque-hex>) -b <preferred-block-size> (16, 32, 64, 128, 256, 512 or 1024 for block-wise) transfers, or 0 to force a non-blockwise transfer -s <filename> : save the response payload to <filename> -t <ack-timeout> : response ACK timeout, in milliseconds -r <max-resend-count>: maximum number of resends upon request timeouts","title":"Usage"},{"location":"tools/coap_client.html#examples","text":"","title":"Examples"},{"location":"tools/coap_client.html#get-request","text":"Send a GET request to a server, running on the local host, for its /helloworld resource $ gg-coap-client get coap://127.0.0.1/helloworld","title":"GET Request"},{"location":"tools/coap_client.html#post-request","text":"Send a POST request to a server, running on the local host, to its /inbox resource, using the contents of the file payload.bin as the request payload. $ gg-coap-client post -p payload.bin coap://127.0.0.1/inbox","title":"POST Request"},{"location":"tools/coap_server.html","text":"CoAP Server Command Line Tool \u00b6 The gg-coap-server tool is a very simple CoAP server that can be used as a test endpoint in examples, and as an easy to understand illustration of how to use some of the C API for CoAP. Usage: gg-coap-server [--port <port>] The --port option may be used to specify that the server should listen on a UDP port other than the default (which is port 5683). The server hosts a simple text resource at path /hello (with an alias at /helloworld ). A GET request to that resource returns the text \"Hello, World\". Furthermore, if a client requests a subpath of /hello , such as /hello/name , the server will respond with the text \"Hello, name\". The server also hosts a CoAP Test Service. Documentation TBD.","title":"CoAP Server"},{"location":"tools/coap_server.html#coap-server-command-line-tool","text":"The gg-coap-server tool is a very simple CoAP server that can be used as a test endpoint in examples, and as an easy to understand illustration of how to use some of the C API for CoAP. Usage: gg-coap-server [--port <port>] The --port option may be used to specify that the server should listen on a UDP port other than the default (which is port 5683). The server hosts a simple text resource at path /hello (with an alias at /helloworld ). A GET request to that resource returns the text \"Hello, World\". Furthermore, if a client requests a subpath of /hello , such as /hello/name , the server will respond with the text \"Hello, name\". The server also hosts a CoAP Test Service. Documentation TBD.","title":"CoAP Server Command Line Tool"},{"location":"tools/stack_tool.html","text":"Stack Tool \u00b6 The Stack Tool is a general purpose command-line tool that can be used to run a Golden Gate stack in a process, and connect the stack's top and bottom ports to UDP sockets so that the stack can communicate with other stacks and/or applications, running on the same host or another host on the network. On macOS, the bottom of the stack can alternatively be connected directly to Bluetooth. The stacks may be full stacks (ex: DTLS <-> UDP <-> IP <-> Gattlink) or subsets, even single element stacks. This makes it possible to split an entire end-to-end communication chain into separate partial stacks that are assembled into a complete stack by connecting the partial stacks over UDP. Usage \u00b6 usage: gg-stack-tool [options] hub|node <stack-descriptor-or-command> where <stack-descriptor-or-command> is either a stack descriptor or a command string starting with a @ character options: --top [coap] <send_host_ip> <send_port> <receive_port> Specify the IP address and port number to connect to the top of the stack (user). If the 'coap' option is used, packets sent and received through the top of the stack are assumed to be CoAP datagrams. (default: 127.0.0.1 9002 9003 as a hub and 127.0.0.1 9003 9002 as a node) --top blast <packet-count> <packet-size> If <packet-count> is not 0, attach a packet blaster to the top of the stack, with the given paket count and packet size, and start blasting, as well as printing stats for packets received from a remote blastera. If <packet-count> or <packet-size> is 0, don't start blasting, only print stats. --top tunnel Connect the top of the stack on an IP tunnel (typically only useful for stacks where the top of the stack produces/consumes IP packets). --bottom <send_host_ip> <send_port> <receive_port> Specify the IP address and port number to connect to the bottom of the stack (transport). (default: 127.0.0.1 9000 9001 as a hub and 127.0.0.1 9001 9000 as a node) --bottom bluetooth <bluetooth-device-id>|scan|node:<advertised-name> In the 'hub' role, connect the bottom of the stack directly to a Bluetooth peripheral, connecting to the device with ID <bluetooth-device-id> (obtained by scanning). Use 'scan' to only scan and display device IDs. In the 'node' role, accept connections from a Bluetooth central (this is mutually exclusive with the --bottom option above). --force-start Don't wait for a link up event from the transport before starting the stack (only valid when the bottom of the stack is bluetooth). --gattlink <max-fragment-size> <rx-window> <tx-window> Specify the Gattlink parameters. --dtls-key <key-identity>:<key> Where <key-identity> is an ASCII string, and <key> is 16 bytes in hex (32 characters) For the `hub` role, multiple --dtls-key options can be used to specify a list of keys. For the `node` role, only one key can be specified. --enable-header-compression Enable header compression --trace Show packets as they are received or sent from the top and bottom sockets. --command-port <command_port> Receive commands on port <command_port> (default: 7000 for hub, 7001 for node). --event-port <event_port> Send events on port <event_port> (default: 7100 for hub, 7101 for node). commands: @reset : reset the stack @dtls-add-key:<key-identity>:<key> : add a DTLS key @bt-connect:<uuid>|scan : connect to a bluetooth device or scan @bt-lc-set-mode:slow|fast : set the preferred link controller connection mode NOTES: * Specify a port number of 0 for the send port of the top or bottom to indicate that the socket should send to the IP address and port number of the latest received packet instead of a fixed address and port. * Specify a port number as 0/X, with X non-zero, for the send port of the top, to indicate that CoAP requests going to through the top should be sent to port X, but CoAP responses should be sent to the port number from which they were received. * Specify a port number of 0 for the receive port of the top or bottom to indicate that the network stack should pick any available port number. Bluetooth \u00b6 On macOS, the tool can interface directly with the operating system's Bluetooth stack. Bluetooth as a Hub \u00b6 The --bottom bluetooth <bluetooth-device-id> option may be used to connect to a bluetooth device running a compatible stack. <bluetooth-device-id> is a macOS-assigned peripheral UUID. To obtain the bluetooth device ID for a specific device, first run the tool with the option --bottom bluetooth scan and look for the device IDs printed on the console. Once you have found the device you are looking for, re-run the tool with the actual bluetooth device ID you want to connect to. Bluetooth as a Node \u00b6 The --bottom bluetooth node:<bluetooth-device-name> option may be used to advertise bluetooth services as a Node. Tip In order to keep the console output reasonably quiet, it is recommended to limit the logging level to INFO, which can be done this way: $ export \"GG_LOG_CONFIG=plist:.level=INFO\" or to trace the operations of the bluetooth transport: $ export \"GG_LOG_CONFIG=plist:gg.xp.app.stack-tool.core-bluetooth.level=ALL;.ConsoleHandler.filter=4;.level=INFO\" Examples \u00b6 In the following examples, we setup stacks or partial stacks connected together so that UDP packets sent to port 5680 are sent through the stacks and come out at the end as a UDP packet sent to localhost (127.0.0.1) on port 5683. This way, we can use a regular CoAP server listening on port 5683, and a regular CoAP client that sends request to the localhost (127.0.0.1) on port 5680, which will be forwarded through the stacks to the sever. Adding the tools to your PATH In the following examples, we assume that the directories where the command line tools are build have been added your PATH . Alternatively, you can use the full path to the tool's executable instead of just the executable name. CoAP Client And Server Through A Stack \u00b6 In these examples, we run two or more stack tool instances (in separate shell processes), configured such that one of the stacks receives packets at its top, on port 5680, from a CoAP client, and communicates with another stack, itself possibly connected to another stack, and so on, until a last stack that sends packets to a CoAP server on port 5683. Network topology: +--------+ +------------+ | | +--------+ | CoAP |---[5680]-->| |-->| any number |---[5683]-->| CoAP | | Client | | Stack Tool | | of Stack |.. | Server | | |<--[any ]---| |<--| Tool |<--[any ]---| | +--------+ +------------+ | processes | +--------+ In each case, once the stacks are running, run the Python CoAP server from CoAPthon $ coapserver.py And then run the CoAP client using the coap NodeJS tool from coap-cli $ coap coap://127.0.0.1:5680/big You should see the CoAP response printed on the console. $ coap coap://127.0.0.1:5680/big ( 2 .05 ) Lorem ipsum dolor sit amet, ... Configuration 1 \u00b6 Simple pair of complete stacks connect to each other on the bottom side. (run each of the following commands in a separate shell): $ gg-stack-tool --top coap 127 .0.0.1 5683 0 hub DSNG $ gg-stack-tool --top coap 127 .0.0.1 0 5680 node DSNG Configuration 2 \u00b6 Completely deconstructed stacks (each stack runs a single layer of a complete stack, so it is like having a stack where each layer runs in a separate process). Advanced example This is an advanced example, intended to illustrate that you can combine multiple stacks together, but in practice you will typically use just one stack on each machine. Run each of the following commands in a separate shell): $ gg-stack-tool --top coap 127 .0.0.1 5683 0 --bottom 127 .0.0.1 9009 9008 --trace hub D $ gg-stack-tool --top 127 .0.0.1 9008 9009 --bottom 127 .0.0.1 9007 9006 --trace --command-port 7001 hub SN $ gg-stack-tool --top 127 .0.0.1 9006 9007 --bottom 127 .0.0.1 9004 9005 --trace --command-port 7002 hub G $ gg-stack-tool --top 127 .0.0.1 9002 9003 --bottom 127 .0.0.1 9005 9004 --trace --command-port 7003 node G $ gg-stack-tool --top 127 .0.0.1 9000 9001 --bottom 127 .0.0.1 9003 9002 --trace --command-port 7004 node SN $ gg-stack-tool --top coap 127 .0.0.1 0 5680 --bottom 127 .0.0.1 9001 9000 --command-port 7005 --trace node D Bluetooth Examples \u00b6 These examples are only available on the mac, not Linux, because the stack tool doesn't yet have native Bluetooth support on Linux desktops. On the mac, the OS assigns a unique device ID to each Bluetooth device it can connect to (instead of exposing the device's Bluetooth address). So the first step is to use the stack tool to scan for devices, which will print on the console a list of compatible Bluetooth devices, along with their OS-assigned device ID. Those device IDs can then be used to connect. Scanning \u00b6 Run $ gg-stack-tool --bottom bluetooth connect hub DSNG If there is a compatible device advertising, you should see on the console something like (see the tip above about setting your GG_LOG_CONFIG environment variable to avoid having too many log lines clutter the console output): Bluetooth Scan: gg-peripheral - ID = DB147848-D227-43A8-A7A7-3AF2530BABC5 RSSI = -34 In this example, we see a device advertising as gg-peripheral for which the OS has assigned ID DB147848-D227-43A8-A7A7-3AF2530BABC5 . Bluetooth Hub Example \u00b6 In this example, we connect to a specific device over Bluetooth (device ID DB147848-D227-43A8-A7A7-3AF2530BABC5 in this example) and we start a stack. The top of the stack is configured to proxy packets on port 5683, so any CoAP client targeting the macOS host will end up being proxy'ed to the device. +--------+ +------------+ | | +-----------+ | CoAP |---[5683]-->| |-->| |----->| GG Device | | Client | | Stack Tool | | Bluetooth | | with CoAP | | |<--[any ]---| |<--| |<-----| server | +--------+ +------------+ | | +-----------+ Run: $ gg-stack-tool --trace --top coap 127 .0.0.1 0 5683 --bottom bluetooth DB147848-D227-43A8-A7A7-3AF2530BABC5 hub DSNG If the device you are connecting to hosts a CoAP server with a /helloworld resource (as would be the case for the Pylon gg-peripheral app running on a Nordic board), you can try a CoAP request like: $ gg-coap-client get coap://127.0.0.1/helloworld You should see: === Received response block, offset=0: code = 2.05 token = 41A73AF1 option 12 [Content-Format] (uint): 0 payload size = 18 payload: 0000: Hello CoAP clien 48656C6C6F20436F415020636C69656E 0016: t! 7421 ### Last block, we're done! Hello CoAP client! Bluetooth Node Example \u00b6 In this example, we start the stack and advertise bluetooth services under the name 'Jiji'. The stack is configured with DTLS, but no key other than the default bootstrap key. The top port is also configured to send CoAP requests out to a local CoAP server that is listening on port 6683. +--------+ | CoAP | | Server |<--+ | | | +--------+ | | +--------+ +-[6683]--->+------------+ | | +-----------+ | CoAP |-----[5683]--->| |-->| |----->| GG Device | | Client | | Stack Tool | | Bluetooth | | with CoAP | | |<----[any ]----| |<--| |<-----| server | +--------+ +------------+ | | +-----------+ Run: $ gg-stack-tool --trace --bottom bluetooth node:Jiji --top 127 .0.0.1 0 /6683 5683 node DSNG","title":"Stack Tool"},{"location":"tools/stack_tool.html#stack-tool","text":"The Stack Tool is a general purpose command-line tool that can be used to run a Golden Gate stack in a process, and connect the stack's top and bottom ports to UDP sockets so that the stack can communicate with other stacks and/or applications, running on the same host or another host on the network. On macOS, the bottom of the stack can alternatively be connected directly to Bluetooth. The stacks may be full stacks (ex: DTLS <-> UDP <-> IP <-> Gattlink) or subsets, even single element stacks. This makes it possible to split an entire end-to-end communication chain into separate partial stacks that are assembled into a complete stack by connecting the partial stacks over UDP.","title":"Stack Tool"},{"location":"tools/stack_tool.html#usage","text":"usage: gg-stack-tool [options] hub|node <stack-descriptor-or-command> where <stack-descriptor-or-command> is either a stack descriptor or a command string starting with a @ character options: --top [coap] <send_host_ip> <send_port> <receive_port> Specify the IP address and port number to connect to the top of the stack (user). If the 'coap' option is used, packets sent and received through the top of the stack are assumed to be CoAP datagrams. (default: 127.0.0.1 9002 9003 as a hub and 127.0.0.1 9003 9002 as a node) --top blast <packet-count> <packet-size> If <packet-count> is not 0, attach a packet blaster to the top of the stack, with the given paket count and packet size, and start blasting, as well as printing stats for packets received from a remote blastera. If <packet-count> or <packet-size> is 0, don't start blasting, only print stats. --top tunnel Connect the top of the stack on an IP tunnel (typically only useful for stacks where the top of the stack produces/consumes IP packets). --bottom <send_host_ip> <send_port> <receive_port> Specify the IP address and port number to connect to the bottom of the stack (transport). (default: 127.0.0.1 9000 9001 as a hub and 127.0.0.1 9001 9000 as a node) --bottom bluetooth <bluetooth-device-id>|scan|node:<advertised-name> In the 'hub' role, connect the bottom of the stack directly to a Bluetooth peripheral, connecting to the device with ID <bluetooth-device-id> (obtained by scanning). Use 'scan' to only scan and display device IDs. In the 'node' role, accept connections from a Bluetooth central (this is mutually exclusive with the --bottom option above). --force-start Don't wait for a link up event from the transport before starting the stack (only valid when the bottom of the stack is bluetooth). --gattlink <max-fragment-size> <rx-window> <tx-window> Specify the Gattlink parameters. --dtls-key <key-identity>:<key> Where <key-identity> is an ASCII string, and <key> is 16 bytes in hex (32 characters) For the `hub` role, multiple --dtls-key options can be used to specify a list of keys. For the `node` role, only one key can be specified. --enable-header-compression Enable header compression --trace Show packets as they are received or sent from the top and bottom sockets. --command-port <command_port> Receive commands on port <command_port> (default: 7000 for hub, 7001 for node). --event-port <event_port> Send events on port <event_port> (default: 7100 for hub, 7101 for node). commands: @reset : reset the stack @dtls-add-key:<key-identity>:<key> : add a DTLS key @bt-connect:<uuid>|scan : connect to a bluetooth device or scan @bt-lc-set-mode:slow|fast : set the preferred link controller connection mode NOTES: * Specify a port number of 0 for the send port of the top or bottom to indicate that the socket should send to the IP address and port number of the latest received packet instead of a fixed address and port. * Specify a port number as 0/X, with X non-zero, for the send port of the top, to indicate that CoAP requests going to through the top should be sent to port X, but CoAP responses should be sent to the port number from which they were received. * Specify a port number of 0 for the receive port of the top or bottom to indicate that the network stack should pick any available port number.","title":"Usage"},{"location":"tools/stack_tool.html#bluetooth","text":"On macOS, the tool can interface directly with the operating system's Bluetooth stack.","title":"Bluetooth"},{"location":"tools/stack_tool.html#bluetooth-as-a-hub","text":"The --bottom bluetooth <bluetooth-device-id> option may be used to connect to a bluetooth device running a compatible stack. <bluetooth-device-id> is a macOS-assigned peripheral UUID. To obtain the bluetooth device ID for a specific device, first run the tool with the option --bottom bluetooth scan and look for the device IDs printed on the console. Once you have found the device you are looking for, re-run the tool with the actual bluetooth device ID you want to connect to.","title":"Bluetooth as a Hub"},{"location":"tools/stack_tool.html#bluetooth-as-a-node","text":"The --bottom bluetooth node:<bluetooth-device-name> option may be used to advertise bluetooth services as a Node. Tip In order to keep the console output reasonably quiet, it is recommended to limit the logging level to INFO, which can be done this way: $ export \"GG_LOG_CONFIG=plist:.level=INFO\" or to trace the operations of the bluetooth transport: $ export \"GG_LOG_CONFIG=plist:gg.xp.app.stack-tool.core-bluetooth.level=ALL;.ConsoleHandler.filter=4;.level=INFO\"","title":"Bluetooth as a Node"},{"location":"tools/stack_tool.html#examples","text":"In the following examples, we setup stacks or partial stacks connected together so that UDP packets sent to port 5680 are sent through the stacks and come out at the end as a UDP packet sent to localhost (127.0.0.1) on port 5683. This way, we can use a regular CoAP server listening on port 5683, and a regular CoAP client that sends request to the localhost (127.0.0.1) on port 5680, which will be forwarded through the stacks to the sever. Adding the tools to your PATH In the following examples, we assume that the directories where the command line tools are build have been added your PATH . Alternatively, you can use the full path to the tool's executable instead of just the executable name.","title":"Examples"},{"location":"tools/stack_tool.html#coap-client-and-server-through-a-stack","text":"In these examples, we run two or more stack tool instances (in separate shell processes), configured such that one of the stacks receives packets at its top, on port 5680, from a CoAP client, and communicates with another stack, itself possibly connected to another stack, and so on, until a last stack that sends packets to a CoAP server on port 5683. Network topology: +--------+ +------------+ | | +--------+ | CoAP |---[5680]-->| |-->| any number |---[5683]-->| CoAP | | Client | | Stack Tool | | of Stack |.. | Server | | |<--[any ]---| |<--| Tool |<--[any ]---| | +--------+ +------------+ | processes | +--------+ In each case, once the stacks are running, run the Python CoAP server from CoAPthon $ coapserver.py And then run the CoAP client using the coap NodeJS tool from coap-cli $ coap coap://127.0.0.1:5680/big You should see the CoAP response printed on the console. $ coap coap://127.0.0.1:5680/big ( 2 .05 ) Lorem ipsum dolor sit amet, ...","title":"CoAP Client And Server Through A Stack"},{"location":"tools/stack_tool.html#configuration-1","text":"Simple pair of complete stacks connect to each other on the bottom side. (run each of the following commands in a separate shell): $ gg-stack-tool --top coap 127 .0.0.1 5683 0 hub DSNG $ gg-stack-tool --top coap 127 .0.0.1 0 5680 node DSNG","title":"Configuration 1"},{"location":"tools/stack_tool.html#configuration-2","text":"Completely deconstructed stacks (each stack runs a single layer of a complete stack, so it is like having a stack where each layer runs in a separate process). Advanced example This is an advanced example, intended to illustrate that you can combine multiple stacks together, but in practice you will typically use just one stack on each machine. Run each of the following commands in a separate shell): $ gg-stack-tool --top coap 127 .0.0.1 5683 0 --bottom 127 .0.0.1 9009 9008 --trace hub D $ gg-stack-tool --top 127 .0.0.1 9008 9009 --bottom 127 .0.0.1 9007 9006 --trace --command-port 7001 hub SN $ gg-stack-tool --top 127 .0.0.1 9006 9007 --bottom 127 .0.0.1 9004 9005 --trace --command-port 7002 hub G $ gg-stack-tool --top 127 .0.0.1 9002 9003 --bottom 127 .0.0.1 9005 9004 --trace --command-port 7003 node G $ gg-stack-tool --top 127 .0.0.1 9000 9001 --bottom 127 .0.0.1 9003 9002 --trace --command-port 7004 node SN $ gg-stack-tool --top coap 127 .0.0.1 0 5680 --bottom 127 .0.0.1 9001 9000 --command-port 7005 --trace node D","title":"Configuration 2"},{"location":"tools/stack_tool.html#bluetooth-examples","text":"These examples are only available on the mac, not Linux, because the stack tool doesn't yet have native Bluetooth support on Linux desktops. On the mac, the OS assigns a unique device ID to each Bluetooth device it can connect to (instead of exposing the device's Bluetooth address). So the first step is to use the stack tool to scan for devices, which will print on the console a list of compatible Bluetooth devices, along with their OS-assigned device ID. Those device IDs can then be used to connect.","title":"Bluetooth Examples"},{"location":"tools/stack_tool.html#scanning","text":"Run $ gg-stack-tool --bottom bluetooth connect hub DSNG If there is a compatible device advertising, you should see on the console something like (see the tip above about setting your GG_LOG_CONFIG environment variable to avoid having too many log lines clutter the console output): Bluetooth Scan: gg-peripheral - ID = DB147848-D227-43A8-A7A7-3AF2530BABC5 RSSI = -34 In this example, we see a device advertising as gg-peripheral for which the OS has assigned ID DB147848-D227-43A8-A7A7-3AF2530BABC5 .","title":"Scanning"},{"location":"tools/stack_tool.html#bluetooth-hub-example","text":"In this example, we connect to a specific device over Bluetooth (device ID DB147848-D227-43A8-A7A7-3AF2530BABC5 in this example) and we start a stack. The top of the stack is configured to proxy packets on port 5683, so any CoAP client targeting the macOS host will end up being proxy'ed to the device. +--------+ +------------+ | | +-----------+ | CoAP |---[5683]-->| |-->| |----->| GG Device | | Client | | Stack Tool | | Bluetooth | | with CoAP | | |<--[any ]---| |<--| |<-----| server | +--------+ +------------+ | | +-----------+ Run: $ gg-stack-tool --trace --top coap 127 .0.0.1 0 5683 --bottom bluetooth DB147848-D227-43A8-A7A7-3AF2530BABC5 hub DSNG If the device you are connecting to hosts a CoAP server with a /helloworld resource (as would be the case for the Pylon gg-peripheral app running on a Nordic board), you can try a CoAP request like: $ gg-coap-client get coap://127.0.0.1/helloworld You should see: === Received response block, offset=0: code = 2.05 token = 41A73AF1 option 12 [Content-Format] (uint): 0 payload size = 18 payload: 0000: Hello CoAP clien 48656C6C6F20436F415020636C69656E 0016: t! 7421 ### Last block, we're done! Hello CoAP client!","title":"Bluetooth Hub Example"},{"location":"tools/stack_tool.html#bluetooth-node-example","text":"In this example, we start the stack and advertise bluetooth services under the name 'Jiji'. The stack is configured with DTLS, but no key other than the default bootstrap key. The top port is also configured to send CoAP requests out to a local CoAP server that is listening on port 6683. +--------+ | CoAP | | Server |<--+ | | | +--------+ | | +--------+ +-[6683]--->+------------+ | | +-----------+ | CoAP |-----[5683]--->| |-->| |----->| GG Device | | Client | | Stack Tool | | Bluetooth | | with CoAP | | |<----[any ]----| |<--| |<-----| server | +--------+ +------------+ | | +-----------+ Run: $ gg-stack-tool --trace --bottom bluetooth node:Jiji --top 127 .0.0.1 0 /6683 5683 node DSNG","title":"Bluetooth Node Example"},{"location":"transports/index.html","text":"","title":"Overview"},{"location":"transports/bluetooth.html","text":"","title":"Bluetooth"},{"location":"transports/wifi.html","text":"","title":"Wifi"}]}