#! /urs/bin/env python

# Copyright 2017-2020 Fitbit, Inc
# SPDX-License-Identifier: Apache-2.0

#####################################################################
# This script post-processes the XCode project generated
# by CMake, so that it no longer contains absolute paths.
# It also remaps UUIDs so that they are stable across invocations
# of this script, which allows the generated project to be put under
# source code control.
#####################################################################

#####################################################################
# Imports
#####################################################################
import sys
import re
import os
import shutil

#####################################################################
# Constants
#####################################################################
XCODE_PROJECT_FILE_NAME = "project.pbxproj"

#####################################################################
def print_usage_and_exit():
    sys.stderr.write("""\
Usage: gg_post_process_xcode_project.py <project_file_in> <project_file_out> <gg_root> <gg_variant>
  Where <project_file_in> is the XCode project generated by CMake,
  <project_file_out> is the post-processed XCode project generated by
  this script, <gg_root> is the directory where the GG repo is checked
  out, and <gg_variant> is 'iOS' or 'macOS'
""")
    sys.exit(1)

#####################################################################
def print_error(error):
    sys.stderr.write("ERROR: %s\n" % (error))

#####################################################################
def replace_substrings(original, replacements):
    cursor = 0
    segments = []
    for replacement in replacements:
        start, end, string = replacement
        segments.append(original[cursor:start])
        segments.append(string)
        cursor = end
    segments.append(original[cursor:])

    return "".join(segments)

#####################################################################
# Even after making paths relative, we still have some include paths
# path point to CMake-generated directories.
# They have the form: xp/build/cmake/<platform>
# We replace them by an equivalent, pointing to the `generated` subdir
# of xp/build
#####################################################################
def fix_header_search_paths(match):
    return match.group(1) + match.group(2).replace('xp/build/cmake', 'xp/build/generated')

#####################################################################
def process_project_file(input_file, output_file, gg_root, uuid_prefix):
    # Read the entire project file
    project = open(os.path.join(input_file, XCODE_PROJECT_FILE_NAME), "r").read()

    # Remove SYMROOT entries, so that we use the default location for XCode
    project = re.sub(r'(SYMROOT = )', r'// Removed by GG script \1', project)

    # Remove CONFIGURATION_BUILD_DIR entries
    project = re.sub(r'(CONFIGURATION_BUILD_DIR = )', r'// Removed by GG script \1', project)

    # Replace defaultConfigurationName to Release
    project = re.sub(r'(defaultConfigurationName = Debug)', r'defaultConfigurationName = Release', project)

    # Compute the relative path from the output project to the GG root
    abs_output_dir_path = os.path.abspath(os.path.dirname(output_file))
    abs_gg_root_path = os.path.abspath(gg_root)
    abs_gg_xp_root_path = os.path.join(abs_gg_root_path, "xp")
    gg_xp_root_relpath = os.path.relpath(abs_gg_xp_root_path, abs_output_dir_path)

    # Rewrite the `projectDirPath` definition in the project
    project_dir_path = "projectDirPath = " + gg_xp_root_relpath + ";"
    project = re.sub(r'projectDirPath = \S+;', project_dir_path, project, 1)

    # Replace absolute paths with paths relative to `projectDirPath`
    project = re.sub(abs_gg_root_path, '..', project)

    # Replace references to object files and libraries.
    # They have the form: ../xp/<some-path>/<prefix>$(EFFECTIVE_PLATFORM_NAME)/<build-variant>/<object-name>
    # We replace them with just the object name, relative to the built products directory.
    # NOTE: those entries can end with a quote, or a whitespace
    project = re.sub(r'(\.\./xp/\S+\$\(EFFECTIVE_PLATFORM_NAME\)/[^/ ]+/)([^/" ]+[" ])', r'$(BUILT_PRODUCTS_DIR)/\2', project)

    # Scan for all entity IDs and store them in a map, associating them with
    # a number equal to their order or appearance in the file
    # Entity IDs generated by CMake: we're looking for a block of 24 uppercase hex chars
    # preceded by whitespace and followed by whitespace or a separator
    entity_id_pattern = re.compile(re.compile(r'(\s)([0-9A-F]{24})(\s|[,;])'))
    entity_id_map = {}
    entity_ids = entity_id_pattern.findall(project)
    for (_, entity_id, _) in entity_ids:
        if entity_id not in entity_id_map:
            entity_id_map[entity_id] = "%s%022X" % (uuid_prefix, len(entity_id_map))

    # Replace IDs with their mapped value
    project = entity_id_pattern.sub(
        lambda match: match.group(1) + entity_id_map[match.group(2)] + match.group(3), project)

    # Fix HEADER_SEARCH_PATHS elements
    # Look for: HEADER_SEARCH_PATHS = (...)
    project = re.sub(r'(HEADER_SEARCH_PATHS\s*=\s*\()([^\(\)]+)', fix_header_search_paths, project)

    # Fix Info.plist references
    project = re.sub(r'(INFOPLIST_FILE\s*=\s*)"(.*GoldenGateXP\.dir/Info.plist)"',
                     r'\1"bundle/Info.plist"',
                     project)

    # Replace the shell script generated by CMake for the gg-common target
    # For simplicity, we just look for a `shellScript` entry with the term `gg-common` in it
    gg_common_shell_script = 'shellScript = "python3 $PROJECT_DIR/build/scripts/gg_process_version_info_header.py \\\"$PROJECT_FILE_PATH/..\\\"";'
    gg_common_input_paths = 'inputPaths = ( "$(BUILT_PRODUCTS_DIR)" );'
    gg_common_output_paths = 'outputPaths = ();'
    project = re.sub(r'shellScript\s*=\s*".*gg-common_preBuildCommands.*";',
                     gg_common_shell_script + "\n" + gg_common_input_paths + "\n" + gg_common_output_paths,
                     project)

    # Replace the ALL_BUILD shell script so that it doesn't depend on a CMake-generated script
    # We use a script file that's just a comment, because we don't need to actually do anything
    all_build_shell_script = 'shellScript = "# replaced by gg_post_process_xcode_project.py";'
    project = re.sub(r'shellScript\s*=\s*".*ALL_BUILD_cmakeRulesBuildPhase.*";',
                     all_build_shell_script,
                     project)

    open(os.path.join(output_file, XCODE_PROJECT_FILE_NAME), "w+").write(project)

#####################################################################
def copy_generated_files(gg_root, gg_variant_dir):
    for filename in ["config/lwipopts.h"]:
        src = os.path.join(gg_root, "xp/build/cmake", gg_variant_dir, filename)
        dst = os.path.join(gg_root, "xp/build/generated", gg_variant_dir, filename)
        if not os.path.exists(os.path.dirname(dst)):
            os.makedirs(os.path.dirname(dst))
        shutil.copyfile(src, dst)

#####################################################################
# main
#####################################################################
def main():
    if len(sys.argv) != 5:
        print_error("ERROR: invalid/missing arguments")
        print_usage_and_exit()

    # Assign the parameters
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    gg_root = sys.argv[3]
    gg_variant = sys.argv[4]

    # Check that the input and output project files are XCode projects (XCode Project files are directories that
    # contain a project.pbxproj file, and other files). For the output, it is Ok that the project.pbxproj file
    # doesn't yet exist, since we will be writing it
    if not os.path.isfile(os.path.join(input_file, XCODE_PROJECT_FILE_NAME)):
        print_error("ERROR: input file is not a valid XCode project")
        return 1

    if not os.path.isdir(output_file):
        print_error("ERROR: output file is not a valid XCode project")
        return 1

    if not os.path.isdir(gg_root):
        print_error("ERROR: Golden Gate root isn't a directory")
        return 1

    # Pick a UUID prefix based on the variant, to try and avoid having the same UUID in two
    # different project files.
    uuid_prefix_map = {
        'iOS': '01',
        'macOS': '02'
    }
    uuid_prefix = uuid_prefix_map.get(gg_variant, '00')
    process_project_file(input_file, output_file, gg_root, uuid_prefix)
    gg_variant_dir = 'xcode-' + gg_variant
    copy_generated_files(gg_root, gg_variant_dir)

    return 0


if __name__ == '__main__':
    sys.exit(main())
